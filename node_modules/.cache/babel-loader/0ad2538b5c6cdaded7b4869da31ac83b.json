{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport { curry, __ as placeholder } from 'ramda';\n\nfunction forOwn(obj, fn) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn(obj[key], key);\n    }\n  }\n}\n\nfunction isArrayLike(value) {\n  return value && _typeof(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;\n}\n\nvar OWNER_ID_TAG = '@@_______immutableOpsOwnerID';\n\nfunction fastArrayCopy(arr) {\n  var copied = new Array(arr.length);\n\n  for (var i = 0; i < arr.length; i++) {\n    copied[i] = arr[i];\n  }\n\n  return copied;\n}\n\nexport function canMutate(obj, ownerID) {\n  if (!ownerID) return false;\n  return obj[OWNER_ID_TAG] === ownerID;\n}\nvar newOwnerID = typeof Symbol === 'function' ? function () {\n  return Symbol('ownerID');\n} : function () {\n  return {};\n};\nexport var getBatchToken = newOwnerID;\n\nfunction addOwnerID(obj, ownerID) {\n  Object.defineProperty(obj, OWNER_ID_TAG, {\n    value: ownerID,\n    configurable: true,\n    enumerable: false\n  });\n  return obj;\n}\n\nfunction prepareNewObject(instance, ownerID) {\n  if (ownerID) {\n    addOwnerID(instance, ownerID);\n  }\n\n  return instance;\n}\n\nfunction forceArray(arg) {\n  if (!(arg instanceof Array)) {\n    return [arg];\n  }\n\n  return arg;\n}\n\nvar PATH_SEPARATOR = '.';\n\nfunction normalizePath(pathArg) {\n  if (typeof pathArg === 'string') {\n    if (pathArg.indexOf(PATH_SEPARATOR) === -1) {\n      return [pathArg];\n    }\n\n    return pathArg.split(PATH_SEPARATOR);\n  }\n\n  return pathArg;\n}\n\nfunction mutableSet(key, value, obj) {\n  obj[key] = value;\n  return obj;\n}\n\nfunction mutableSetIn(_pathArg, value, obj) {\n  var originalPathArg = normalizePath(_pathArg);\n  var pathLen = originalPathArg.length;\n  var done = false;\n  var idx = 0;\n  var acc = obj;\n  var curr = originalPathArg[idx];\n\n  while (!done) {\n    if (idx === pathLen - 1) {\n      acc[curr] = value;\n      done = true;\n    } else {\n      var currType = _typeof(acc[curr]);\n\n      if (currType === 'undefined') {\n        var newObj = {};\n        prepareNewObject(newObj, null);\n        acc[curr] = newObj;\n      } else if (currType !== 'object') {\n        var pathRepr = \"\".concat(originalPathArg[idx - 1], \".\").concat(curr);\n        throw new Error(\"A non-object value was encountered when traversing setIn path at \".concat(pathRepr, \".\"));\n      }\n\n      acc = acc[curr];\n      idx++;\n      curr = originalPathArg[idx];\n    }\n  }\n\n  return obj;\n}\n\nfunction valueInPath(_pathArg, obj) {\n  var pathArg = normalizePath(_pathArg);\n  var acc = obj;\n\n  for (var i = 0; i < pathArg.length; i++) {\n    var curr = pathArg[i];\n    var currRef = acc[curr];\n\n    if (i === pathArg.length - 1) {\n      return currRef;\n    }\n\n    if (_typeof(currRef) === 'object') {\n      acc = currRef;\n    } else {\n      return undefined;\n    }\n  }\n\n  return undefined;\n}\n\nfunction immutableSetIn(ownerID, _pathArg, value, obj) {\n  var pathArg = normalizePath(_pathArg);\n  var currentValue = valueInPath(pathArg, obj);\n  if (value === currentValue) return obj;\n  var pathLen = pathArg.length;\n  var acc;\n\n  if (canMutate(obj, ownerID)) {\n    acc = obj;\n  } else {\n    acc = Object.assign(prepareNewObject({}, ownerID), obj);\n  }\n\n  var rootObj = acc;\n  pathArg.forEach(function (curr, idx) {\n    if (idx === pathLen - 1) {\n      acc[curr] = value;\n      return;\n    }\n\n    var currRef = acc[curr];\n\n    var currType = _typeof(currRef);\n\n    if (currType === 'object') {\n      if (canMutate(currRef, ownerID)) {\n        acc = currRef;\n      } else {\n        var newObj = prepareNewObject({}, ownerID);\n        acc[curr] = Object.assign(newObj, currRef);\n        acc = newObj;\n      }\n\n      return;\n    }\n\n    if (currType === 'undefined') {\n      var _newObj = prepareNewObject({}, ownerID);\n\n      acc[curr] = _newObj;\n      acc = _newObj;\n      return;\n    }\n\n    var pathRepr = \"\".concat(pathArg[idx - 1], \".\").concat(curr);\n    throw new Error(\"A non-object value was encountered when traversing setIn path at \".concat(pathRepr, \".\"));\n  });\n  return rootObj;\n}\n\nfunction mutableMerge(isDeep, _mergeObjs, baseObj) {\n  var mergeObjs = forceArray(_mergeObjs);\n\n  if (isDeep) {\n    mergeObjs.forEach(function (mergeObj) {\n      forOwn(mergeObj, function (value, key) {\n        if (isDeep && baseObj.hasOwnProperty(key)) {\n          var assignValue;\n\n          if (_typeof(value) === 'object') {\n            assignValue = mutableMerge(isDeep, [value], baseObj[key]);\n          } else {\n            assignValue = value;\n          }\n\n          baseObj[key] = assignValue;\n        } else {\n          baseObj[key] = value;\n        }\n      });\n    });\n  } else {\n    Object.assign.apply(Object, [baseObj].concat(_toConsumableArray(mergeObjs)));\n  }\n\n  return baseObj;\n}\n\nvar mutableShallowMerge = mutableMerge.bind(null, false);\nvar mutableDeepMerge = mutableMerge.bind(null, true);\n\nfunction mutableOmit(_keys, obj) {\n  var keys = forceArray(_keys);\n  keys.forEach(function (key) {\n    delete obj[key];\n  });\n  return obj;\n}\n\nfunction shouldMergeKey(obj, other, key) {\n  return obj[key] !== other[key];\n}\n\nfunction immutableMerge(isDeep, ownerID, _mergeObjs, obj) {\n  if (canMutate(obj, ownerID)) return mutableMerge(isDeep, _mergeObjs, obj);\n  var mergeObjs = forceArray(_mergeObjs);\n  var hasChanges = false;\n  var nextObject = obj;\n\n  var willChange = function willChange() {\n    if (!hasChanges) {\n      hasChanges = true;\n      nextObject = Object.assign({}, obj);\n      prepareNewObject(nextObject, ownerID);\n    }\n  };\n\n  mergeObjs.forEach(function (mergeObj) {\n    forOwn(mergeObj, function (mergeValue, key) {\n      if (isDeep && obj.hasOwnProperty(key)) {\n        var currentValue = nextObject[key];\n\n        if (_typeof(mergeValue) === 'object' && !(mergeValue instanceof Array)) {\n          if (shouldMergeKey(nextObject, mergeObj, key)) {\n            var recursiveMergeResult = immutableMerge(isDeep, ownerID, mergeValue, currentValue);\n\n            if (recursiveMergeResult !== currentValue) {\n              willChange();\n              nextObject[key] = recursiveMergeResult;\n            }\n          }\n\n          return true; // continue forOwn\n        }\n      }\n\n      if (shouldMergeKey(nextObject, mergeObj, key)) {\n        willChange();\n        nextObject[key] = mergeValue;\n      }\n\n      return undefined;\n    });\n  });\n  return nextObject;\n}\n\nvar immutableDeepMerge = immutableMerge.bind(null, true);\nvar immutableShallowMerge = immutableMerge.bind(null, false);\n\nfunction immutableArrSet(ownerID, index, value, arr) {\n  if (canMutate(arr, ownerID)) return mutableSet(index, value, arr);\n  if (arr[index] === value) return arr;\n  var newArr = fastArrayCopy(arr);\n  newArr[index] = value;\n  prepareNewObject(newArr, ownerID);\n  return newArr;\n}\n\nfunction immutableSet(ownerID, key, value, obj) {\n  if (isArrayLike(obj)) return immutableArrSet(ownerID, key, value, obj);\n  if (canMutate(obj, ownerID)) return mutableSet(key, value, obj);\n  if (obj[key] === value) return obj;\n  var newObj = Object.assign({}, obj);\n  prepareNewObject(newObj, ownerID);\n  newObj[key] = value;\n  return newObj;\n}\n\nfunction immutableOmit(ownerID, _keys, obj) {\n  if (canMutate(obj, ownerID)) return mutableOmit(_keys, obj);\n  var keys = forceArray(_keys);\n  var keysInObj = keys.filter(function (key) {\n    return obj.hasOwnProperty(key);\n  }); // None of the keys were in the object, so we can return `obj`.\n\n  if (keysInObj.length === 0) return obj;\n  var newObj = Object.assign({}, obj);\n  keysInObj.forEach(function (key) {\n    delete newObj[key];\n  });\n  prepareNewObject(newObj, ownerID);\n  return newObj;\n}\n\nfunction mutableArrPush(_vals, arr) {\n  var vals = forceArray(_vals);\n  arr.push.apply(arr, _toConsumableArray(vals));\n  return arr;\n}\n\nfunction mutableArrFilter(func, arr) {\n  var currIndex = 0;\n  var originalIndex = 0;\n\n  while (currIndex < arr.length) {\n    var item = arr[currIndex];\n\n    if (!func(item, originalIndex)) {\n      arr.splice(currIndex, 1);\n    } else {\n      currIndex++;\n    }\n\n    originalIndex++;\n  }\n\n  return arr;\n}\n\nfunction mutableArrSplice(index, deleteCount, _vals, arr) {\n  var vals = forceArray(_vals);\n  arr.splice.apply(arr, [index, deleteCount].concat(_toConsumableArray(vals)));\n  return arr;\n}\n\nfunction mutableArrInsert(index, _vals, arr) {\n  return mutableArrSplice(index, 0, _vals, arr);\n}\n\nfunction immutableArrSplice(ownerID, index, deleteCount, _vals, arr) {\n  if (canMutate(arr, ownerID)) return mutableArrSplice(index, deleteCount, _vals, arr);\n  var vals = forceArray(_vals);\n  var newArr = arr.slice();\n  prepareNewObject(newArr, ownerID);\n  newArr.splice.apply(newArr, [index, deleteCount].concat(_toConsumableArray(vals)));\n  return newArr;\n}\n\nfunction immutableArrInsert(ownerID, index, _vals, arr) {\n  if (canMutate(arr, ownerID)) return mutableArrInsert(index, _vals, arr);\n  return immutableArrSplice(ownerID, index, 0, _vals, arr);\n}\n\nfunction immutableArrPush(ownerID, vals, arr) {\n  return immutableArrInsert(ownerID, arr.length, vals, arr);\n}\n\nfunction immutableArrFilter(ownerID, func, arr) {\n  if (canMutate(arr, ownerID)) return mutableArrFilter(func, arr);\n  var newArr = arr.filter(func);\n  if (newArr.length === arr.length) return arr;\n  prepareNewObject(newArr, ownerID);\n  return newArr;\n}\n\nvar immutableOperations = {\n  // object operations\n  merge: immutableShallowMerge,\n  deepMerge: immutableDeepMerge,\n  omit: immutableOmit,\n  setIn: immutableSetIn,\n  // array operations\n  insert: immutableArrInsert,\n  push: immutableArrPush,\n  filter: immutableArrFilter,\n  splice: immutableArrSplice,\n  // both\n  set: immutableSet\n};\nvar mutableOperations = {\n  // object operations\n  merge: mutableShallowMerge,\n  deepMerge: mutableDeepMerge,\n  omit: mutableOmit,\n  setIn: mutableSetIn,\n  // array operations\n  insert: mutableArrInsert,\n  push: mutableArrPush,\n  filter: mutableArrFilter,\n  splice: mutableArrSplice,\n  // both\n  set: mutableSet\n};\nexport function getImmutableOps() {\n  var immutableOps = Object.assign({}, immutableOperations);\n  forOwn(immutableOps, function (value, key) {\n    immutableOps[key] = curry(value.bind(null, null));\n  });\n  var mutableOps = Object.assign({}, mutableOperations);\n  forOwn(mutableOps, function (value, key) {\n    mutableOps[key] = curry(value);\n  });\n  var batchOps = Object.assign({}, immutableOperations);\n  forOwn(batchOps, function (value, key) {\n    batchOps[key] = curry(value);\n  });\n\n  function batched(_token, _fn) {\n    var token;\n    var fn;\n\n    if (typeof _token === 'function') {\n      fn = _token;\n      token = getBatchToken();\n    } else {\n      token = _token;\n      fn = _fn;\n    }\n\n    var immutableOpsBoundToToken = Object.assign({}, immutableOperations);\n    forOwn(immutableOpsBoundToToken, function (value, key) {\n      immutableOpsBoundToToken[key] = curry(value.bind(null, token));\n    });\n    return fn(immutableOpsBoundToToken);\n  }\n\n  return Object.assign(immutableOps, {\n    mutable: mutableOps,\n    batch: batchOps,\n    batched: batched,\n    __: placeholder,\n    getBatchToken: getBatchToken\n  });\n}\nexport var ops = getImmutableOps();\nexport default ops;","map":{"version":3,"names":["_toConsumableArray","_typeof","curry","__","placeholder","forOwn","obj","fn","key","hasOwnProperty","isArrayLike","value","length","OWNER_ID_TAG","fastArrayCopy","arr","copied","Array","i","canMutate","ownerID","newOwnerID","Symbol","getBatchToken","addOwnerID","Object","defineProperty","configurable","enumerable","prepareNewObject","instance","forceArray","arg","PATH_SEPARATOR","normalizePath","pathArg","indexOf","split","mutableSet","mutableSetIn","_pathArg","originalPathArg","pathLen","done","idx","acc","curr","currType","newObj","pathRepr","concat","Error","valueInPath","currRef","undefined","immutableSetIn","currentValue","assign","rootObj","forEach","_newObj","mutableMerge","isDeep","_mergeObjs","baseObj","mergeObjs","mergeObj","assignValue","apply","mutableShallowMerge","bind","mutableDeepMerge","mutableOmit","_keys","keys","shouldMergeKey","other","immutableMerge","hasChanges","nextObject","willChange","mergeValue","recursiveMergeResult","immutableDeepMerge","immutableShallowMerge","immutableArrSet","index","newArr","immutableSet","immutableOmit","keysInObj","filter","mutableArrPush","_vals","vals","push","mutableArrFilter","func","currIndex","originalIndex","item","splice","mutableArrSplice","deleteCount","mutableArrInsert","immutableArrSplice","slice","immutableArrInsert","immutableArrPush","immutableArrFilter","immutableOperations","merge","deepMerge","omit","setIn","insert","set","mutableOperations","getImmutableOps","immutableOps","mutableOps","batchOps","batched","_token","_fn","token","immutableOpsBoundToToken","mutable","batch","ops"],"sources":["/Users/developer/task/task3/node_modules/immutable-ops/es/index.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport { curry, __ as placeholder } from 'ramda';\n\nfunction forOwn(obj, fn) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn(obj[key], key);\n    }\n  }\n}\n\nfunction isArrayLike(value) {\n  return value && _typeof(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;\n}\n\nvar OWNER_ID_TAG = '@@_______immutableOpsOwnerID';\n\nfunction fastArrayCopy(arr) {\n  var copied = new Array(arr.length);\n\n  for (var i = 0; i < arr.length; i++) {\n    copied[i] = arr[i];\n  }\n\n  return copied;\n}\n\nexport function canMutate(obj, ownerID) {\n  if (!ownerID) return false;\n  return obj[OWNER_ID_TAG] === ownerID;\n}\nvar newOwnerID = typeof Symbol === 'function' ? function () {\n  return Symbol('ownerID');\n} : function () {\n  return {};\n};\nexport var getBatchToken = newOwnerID;\n\nfunction addOwnerID(obj, ownerID) {\n  Object.defineProperty(obj, OWNER_ID_TAG, {\n    value: ownerID,\n    configurable: true,\n    enumerable: false\n  });\n  return obj;\n}\n\nfunction prepareNewObject(instance, ownerID) {\n  if (ownerID) {\n    addOwnerID(instance, ownerID);\n  }\n\n  return instance;\n}\n\nfunction forceArray(arg) {\n  if (!(arg instanceof Array)) {\n    return [arg];\n  }\n\n  return arg;\n}\n\nvar PATH_SEPARATOR = '.';\n\nfunction normalizePath(pathArg) {\n  if (typeof pathArg === 'string') {\n    if (pathArg.indexOf(PATH_SEPARATOR) === -1) {\n      return [pathArg];\n    }\n\n    return pathArg.split(PATH_SEPARATOR);\n  }\n\n  return pathArg;\n}\n\nfunction mutableSet(key, value, obj) {\n  obj[key] = value;\n  return obj;\n}\n\nfunction mutableSetIn(_pathArg, value, obj) {\n  var originalPathArg = normalizePath(_pathArg);\n  var pathLen = originalPathArg.length;\n  var done = false;\n  var idx = 0;\n  var acc = obj;\n  var curr = originalPathArg[idx];\n\n  while (!done) {\n    if (idx === pathLen - 1) {\n      acc[curr] = value;\n      done = true;\n    } else {\n      var currType = _typeof(acc[curr]);\n\n      if (currType === 'undefined') {\n        var newObj = {};\n        prepareNewObject(newObj, null);\n        acc[curr] = newObj;\n      } else if (currType !== 'object') {\n        var pathRepr = \"\".concat(originalPathArg[idx - 1], \".\").concat(curr);\n        throw new Error(\"A non-object value was encountered when traversing setIn path at \".concat(pathRepr, \".\"));\n      }\n\n      acc = acc[curr];\n      idx++;\n      curr = originalPathArg[idx];\n    }\n  }\n\n  return obj;\n}\n\nfunction valueInPath(_pathArg, obj) {\n  var pathArg = normalizePath(_pathArg);\n  var acc = obj;\n\n  for (var i = 0; i < pathArg.length; i++) {\n    var curr = pathArg[i];\n    var currRef = acc[curr];\n\n    if (i === pathArg.length - 1) {\n      return currRef;\n    }\n\n    if (_typeof(currRef) === 'object') {\n      acc = currRef;\n    } else {\n      return undefined;\n    }\n  }\n\n  return undefined;\n}\n\nfunction immutableSetIn(ownerID, _pathArg, value, obj) {\n  var pathArg = normalizePath(_pathArg);\n  var currentValue = valueInPath(pathArg, obj);\n  if (value === currentValue) return obj;\n  var pathLen = pathArg.length;\n  var acc;\n\n  if (canMutate(obj, ownerID)) {\n    acc = obj;\n  } else {\n    acc = Object.assign(prepareNewObject({}, ownerID), obj);\n  }\n\n  var rootObj = acc;\n  pathArg.forEach(function (curr, idx) {\n    if (idx === pathLen - 1) {\n      acc[curr] = value;\n      return;\n    }\n\n    var currRef = acc[curr];\n\n    var currType = _typeof(currRef);\n\n    if (currType === 'object') {\n      if (canMutate(currRef, ownerID)) {\n        acc = currRef;\n      } else {\n        var newObj = prepareNewObject({}, ownerID);\n        acc[curr] = Object.assign(newObj, currRef);\n        acc = newObj;\n      }\n\n      return;\n    }\n\n    if (currType === 'undefined') {\n      var _newObj = prepareNewObject({}, ownerID);\n\n      acc[curr] = _newObj;\n      acc = _newObj;\n      return;\n    }\n\n    var pathRepr = \"\".concat(pathArg[idx - 1], \".\").concat(curr);\n    throw new Error(\"A non-object value was encountered when traversing setIn path at \".concat(pathRepr, \".\"));\n  });\n  return rootObj;\n}\n\nfunction mutableMerge(isDeep, _mergeObjs, baseObj) {\n  var mergeObjs = forceArray(_mergeObjs);\n\n  if (isDeep) {\n    mergeObjs.forEach(function (mergeObj) {\n      forOwn(mergeObj, function (value, key) {\n        if (isDeep && baseObj.hasOwnProperty(key)) {\n          var assignValue;\n\n          if (_typeof(value) === 'object') {\n            assignValue = mutableMerge(isDeep, [value], baseObj[key]);\n          } else {\n            assignValue = value;\n          }\n\n          baseObj[key] = assignValue;\n        } else {\n          baseObj[key] = value;\n        }\n      });\n    });\n  } else {\n    Object.assign.apply(Object, [baseObj].concat(_toConsumableArray(mergeObjs)));\n  }\n\n  return baseObj;\n}\n\nvar mutableShallowMerge = mutableMerge.bind(null, false);\nvar mutableDeepMerge = mutableMerge.bind(null, true);\n\nfunction mutableOmit(_keys, obj) {\n  var keys = forceArray(_keys);\n  keys.forEach(function (key) {\n    delete obj[key];\n  });\n  return obj;\n}\n\nfunction shouldMergeKey(obj, other, key) {\n  return obj[key] !== other[key];\n}\n\nfunction immutableMerge(isDeep, ownerID, _mergeObjs, obj) {\n  if (canMutate(obj, ownerID)) return mutableMerge(isDeep, _mergeObjs, obj);\n  var mergeObjs = forceArray(_mergeObjs);\n  var hasChanges = false;\n  var nextObject = obj;\n\n  var willChange = function willChange() {\n    if (!hasChanges) {\n      hasChanges = true;\n      nextObject = Object.assign({}, obj);\n      prepareNewObject(nextObject, ownerID);\n    }\n  };\n\n  mergeObjs.forEach(function (mergeObj) {\n    forOwn(mergeObj, function (mergeValue, key) {\n      if (isDeep && obj.hasOwnProperty(key)) {\n        var currentValue = nextObject[key];\n\n        if (_typeof(mergeValue) === 'object' && !(mergeValue instanceof Array)) {\n          if (shouldMergeKey(nextObject, mergeObj, key)) {\n            var recursiveMergeResult = immutableMerge(isDeep, ownerID, mergeValue, currentValue);\n\n            if (recursiveMergeResult !== currentValue) {\n              willChange();\n              nextObject[key] = recursiveMergeResult;\n            }\n          }\n\n          return true; // continue forOwn\n        }\n      }\n\n      if (shouldMergeKey(nextObject, mergeObj, key)) {\n        willChange();\n        nextObject[key] = mergeValue;\n      }\n\n      return undefined;\n    });\n  });\n  return nextObject;\n}\n\nvar immutableDeepMerge = immutableMerge.bind(null, true);\nvar immutableShallowMerge = immutableMerge.bind(null, false);\n\nfunction immutableArrSet(ownerID, index, value, arr) {\n  if (canMutate(arr, ownerID)) return mutableSet(index, value, arr);\n  if (arr[index] === value) return arr;\n  var newArr = fastArrayCopy(arr);\n  newArr[index] = value;\n  prepareNewObject(newArr, ownerID);\n  return newArr;\n}\n\nfunction immutableSet(ownerID, key, value, obj) {\n  if (isArrayLike(obj)) return immutableArrSet(ownerID, key, value, obj);\n  if (canMutate(obj, ownerID)) return mutableSet(key, value, obj);\n  if (obj[key] === value) return obj;\n  var newObj = Object.assign({}, obj);\n  prepareNewObject(newObj, ownerID);\n  newObj[key] = value;\n  return newObj;\n}\n\nfunction immutableOmit(ownerID, _keys, obj) {\n  if (canMutate(obj, ownerID)) return mutableOmit(_keys, obj);\n  var keys = forceArray(_keys);\n  var keysInObj = keys.filter(function (key) {\n    return obj.hasOwnProperty(key);\n  }); // None of the keys were in the object, so we can return `obj`.\n\n  if (keysInObj.length === 0) return obj;\n  var newObj = Object.assign({}, obj);\n  keysInObj.forEach(function (key) {\n    delete newObj[key];\n  });\n  prepareNewObject(newObj, ownerID);\n  return newObj;\n}\n\nfunction mutableArrPush(_vals, arr) {\n  var vals = forceArray(_vals);\n  arr.push.apply(arr, _toConsumableArray(vals));\n  return arr;\n}\n\nfunction mutableArrFilter(func, arr) {\n  var currIndex = 0;\n  var originalIndex = 0;\n\n  while (currIndex < arr.length) {\n    var item = arr[currIndex];\n\n    if (!func(item, originalIndex)) {\n      arr.splice(currIndex, 1);\n    } else {\n      currIndex++;\n    }\n\n    originalIndex++;\n  }\n\n  return arr;\n}\n\nfunction mutableArrSplice(index, deleteCount, _vals, arr) {\n  var vals = forceArray(_vals);\n  arr.splice.apply(arr, [index, deleteCount].concat(_toConsumableArray(vals)));\n  return arr;\n}\n\nfunction mutableArrInsert(index, _vals, arr) {\n  return mutableArrSplice(index, 0, _vals, arr);\n}\n\nfunction immutableArrSplice(ownerID, index, deleteCount, _vals, arr) {\n  if (canMutate(arr, ownerID)) return mutableArrSplice(index, deleteCount, _vals, arr);\n  var vals = forceArray(_vals);\n  var newArr = arr.slice();\n  prepareNewObject(newArr, ownerID);\n  newArr.splice.apply(newArr, [index, deleteCount].concat(_toConsumableArray(vals)));\n  return newArr;\n}\n\nfunction immutableArrInsert(ownerID, index, _vals, arr) {\n  if (canMutate(arr, ownerID)) return mutableArrInsert(index, _vals, arr);\n  return immutableArrSplice(ownerID, index, 0, _vals, arr);\n}\n\nfunction immutableArrPush(ownerID, vals, arr) {\n  return immutableArrInsert(ownerID, arr.length, vals, arr);\n}\n\nfunction immutableArrFilter(ownerID, func, arr) {\n  if (canMutate(arr, ownerID)) return mutableArrFilter(func, arr);\n  var newArr = arr.filter(func);\n  if (newArr.length === arr.length) return arr;\n  prepareNewObject(newArr, ownerID);\n  return newArr;\n}\n\nvar immutableOperations = {\n  // object operations\n  merge: immutableShallowMerge,\n  deepMerge: immutableDeepMerge,\n  omit: immutableOmit,\n  setIn: immutableSetIn,\n  // array operations\n  insert: immutableArrInsert,\n  push: immutableArrPush,\n  filter: immutableArrFilter,\n  splice: immutableArrSplice,\n  // both\n  set: immutableSet\n};\nvar mutableOperations = {\n  // object operations\n  merge: mutableShallowMerge,\n  deepMerge: mutableDeepMerge,\n  omit: mutableOmit,\n  setIn: mutableSetIn,\n  // array operations\n  insert: mutableArrInsert,\n  push: mutableArrPush,\n  filter: mutableArrFilter,\n  splice: mutableArrSplice,\n  // both\n  set: mutableSet\n};\nexport function getImmutableOps() {\n  var immutableOps = Object.assign({}, immutableOperations);\n  forOwn(immutableOps, function (value, key) {\n    immutableOps[key] = curry(value.bind(null, null));\n  });\n  var mutableOps = Object.assign({}, mutableOperations);\n  forOwn(mutableOps, function (value, key) {\n    mutableOps[key] = curry(value);\n  });\n  var batchOps = Object.assign({}, immutableOperations);\n  forOwn(batchOps, function (value, key) {\n    batchOps[key] = curry(value);\n  });\n\n  function batched(_token, _fn) {\n    var token;\n    var fn;\n\n    if (typeof _token === 'function') {\n      fn = _token;\n      token = getBatchToken();\n    } else {\n      token = _token;\n      fn = _fn;\n    }\n\n    var immutableOpsBoundToToken = Object.assign({}, immutableOperations);\n    forOwn(immutableOpsBoundToToken, function (value, key) {\n      immutableOpsBoundToToken[key] = curry(value.bind(null, token));\n    });\n    return fn(immutableOpsBoundToToken);\n  }\n\n  return Object.assign(immutableOps, {\n    mutable: mutableOps,\n    batch: batchOps,\n    batched: batched,\n    __: placeholder,\n    getBatchToken: getBatchToken\n  });\n}\nexport var ops = getImmutableOps();\nexport default ops;"],"mappings":"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"},"metadata":{},"sourceType":"module"}