{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport ops from \"immutable-ops\";\nimport filter from \"lodash/filter\";\nimport orderBy from \"lodash/orderBy\";\nimport reject from \"lodash/reject\";\nimport sortBy from \"lodash/sortBy\";\nimport { EXCLUDE, FILTER, ORDER_BY } from \"../constants\";\nimport { clauseFiltersByAttribute, clauseReducesResultSetSize } from \"../utils\";\nvar DEFAULT_TABLE_OPTIONS = {\n  idAttribute: \"id\",\n  arrName: \"items\",\n  mapName: \"itemsById\",\n  fields: {}\n};\n/**\n * @private\n * @param {*} _currMax - the current max id\n * @param {*} userPassedId - the new id passed to the create action\n *\n * Both may be undefined. The current max id in the case that this is the first Model\n * being created, and the new id if the id was not explicitly passed to the\n * database.\n *\n * @return {Array} the new max id and the id to use to create the new row\n *\n * If the id's are strings, the id must be passed explicitly every time.\n * In this case, the current max id will remain `NaN` due to `Math.max`, but that's fine.\n */\n\nfunction idSequencer(_currMax, userPassedId) {\n  var currMax = _currMax;\n  var newMax;\n  var newId;\n\n  if (currMax === undefined) {\n    currMax = -1;\n  }\n\n  if (userPassedId === undefined) {\n    newMax = currMax + 1;\n    newId = newMax;\n  } else {\n    newMax = Math.max(currMax + 1, userPassedId);\n    newId = userPassedId;\n  }\n\n  return [newMax, // new max id\n  newId // id to use for row creation\n  ];\n}\n/**\n * Adapt order directions array to @{lodash.orderBy} API.\n *\n * @private\n *\n * @param {Array<Boolean|'asc'|'desc'>} orders? - an array of optional order query directions as provided to {@Link {QuerySet.orderBy}}\n * @return {Array<'asc'|'desc'>|undefined} A normalized ordering array or undefined if none was provided.\n */\n\n\nfunction normalizeOrders(orders) {\n  if (orders === undefined) {\n    return undefined;\n  }\n\n  var convert = function convert(order) {\n    if ([\"desc\", false].includes(order)) {\n      return \"desc\";\n    }\n\n    return \"asc\";\n  };\n\n  return Array.isArray(orders) ? orders.map(convert) : convert(orders);\n}\n/**\n * Handles the underlying data structure for a {@link Model} class.\n * @private\n */\n\n\nexport var Table = /*#__PURE__*/function () {\n  /**\n   * Creates a new {@link Table} instance.\n   * @param  {Object} userOpts - options to use.\n   * @param  {string} [userOpts.idAttribute=id] - the id attribute of the entity.\n   * @param  {string} [userOpts.arrName=items] - the state attribute where an array of\n   *                                             entity id's are stored\n   * @param  {string} [userOpts.mapName=itemsById] - the state attribute where the entity objects\n   *                                                 are stored in a id to entity object\n   *                                                 map.\n   * @param  {string} [userOpts.fields={}] - mapping of field key to {@link Field} object\n   */\n  function Table(userOpts) {\n    Object.assign(this, DEFAULT_TABLE_OPTIONS, userOpts);\n  }\n  /**\n   * Returns a reference to the object at index `id`\n   * in state `branch`.\n   *\n   * @param  {Object} branch - the state\n   * @param  {Number} id - the id of the object to get\n   * @return {Object|undefined} A reference to the raw object in the state or\n   *                            `undefined` if not found.\n   */\n\n\n  var _proto = Table.prototype;\n\n  _proto.accessId = function accessId(branch, id) {\n    return branch[this.mapName][id];\n  };\n\n  _proto.accessIds = function accessIds(branch, ids) {\n    var map = branch[this.mapName];\n    return ids.map(function (id) {\n      return map[id];\n    });\n  };\n\n  _proto.idExists = function idExists(branch, id) {\n    return branch[this.mapName].hasOwnProperty(id);\n  };\n\n  _proto.accessIdList = function accessIdList(branch) {\n    return branch[this.arrName];\n  };\n\n  _proto.accessList = function accessList(branch) {\n    return this.accessIds(branch, this.accessIdList(branch));\n  };\n\n  _proto.getMaxId = function getMaxId(branch) {\n    return this.getMeta(branch, \"maxId\");\n  };\n\n  _proto.setMaxId = function setMaxId(tx, branch, newMaxId) {\n    return this.setMeta(tx, branch, \"maxId\", newMaxId);\n  };\n\n  _proto.nextId = function nextId(id) {\n    return id + 1;\n  }\n  /**\n   * Returns the default state for the data structure.\n   * @return {Object} The default state for this {@link ORM} instance's data structure\n   */\n  ;\n\n  _proto.getEmptyState = function getEmptyState() {\n    var _pkIndex,\n        _this = this;\n\n    var pkIndex = (_pkIndex = {}, _defineProperty(_pkIndex, this.arrName, []), _defineProperty(_pkIndex, this.mapName, {}), _pkIndex);\n    var attrIndexes = Object.keys(this.fields).filter(function (attr) {\n      return attr !== _this.idAttribute;\n    }).filter(function (attr) {\n      return _this.fields[attr].index;\n    }).reduce(function (indexes, attr) {\n      return _objectSpread(_objectSpread({}, indexes), {}, _defineProperty({}, attr, {}));\n    }, {});\n    return _objectSpread(_objectSpread({}, pkIndex), {}, {\n      indexes: attrIndexes,\n      meta: {}\n    });\n  };\n\n  _proto.setMeta = function setMeta(tx, branch, key, value) {\n    var batchToken = tx.batchToken,\n        withMutations = tx.withMutations;\n\n    if (withMutations) {\n      var res = ops.mutable.setIn([\"meta\", key], value, branch);\n      return res;\n    }\n\n    return ops.batch.setIn(batchToken, [\"meta\", key], value, branch);\n  };\n\n  _proto.getMeta = function getMeta(branch, key) {\n    return branch.meta[key];\n  };\n\n  _proto.query = function query(branch, clauses) {\n    var _this2 = this;\n\n    if (clauses.length === 0) {\n      return this.accessList(branch);\n    }\n\n    var idAttribute = this.idAttribute;\n    var optimallyOrderedClauses = sortBy(clauses, function (clause) {\n      if (clauseFiltersByAttribute(clause, idAttribute)) {\n        return 1;\n      }\n\n      if (clauseReducesResultSetSize(clause)) {\n        return 2;\n      }\n\n      return 3;\n    });\n\n    var reducer = function reducer(rows, clause) {\n      var type = clause.type,\n          payload = clause.payload;\n\n      if (!rows) {\n        /**\n         * First time this reducer is called during query.\n         * This is where we apply query optimizations.\n         */\n        if (clauseFiltersByAttribute(clause, idAttribute)) {\n          /**\n           * Payload specified a primary key. Use PK index\n           * to look up the single row identified by the PK.\n           */\n          var id = payload[idAttribute];\n          var remainingPayload = Object.keys(payload).reduce(function (withoutPkAttr, filterAttr) {\n            if (filterAttr !== idAttribute) {\n              withoutPkAttr[filterAttr] = payload[filterAttr];\n            }\n\n            return withoutPkAttr;\n          }, {});\n          var ids = _this2.idExists(branch, id) ? [id] : [];\n\n          if (Object.keys(remainingPayload).length) {\n            /**\n             * Payload has additional, non-PK columns.\n             * Filter accessed row by remaining payload (if one was found).\n             */\n            return reducer(_this2.accessIds(branch, ids), _objectSpread(_objectSpread({}, clause), {}, {\n              payload: remainingPayload\n            }));\n          }\n          /**\n           * No need to filter these rows any further.\n           * The primary key value satisfies this clause's conditions.\n           */\n\n\n          return _this2.accessIds(branch, ids);\n        }\n\n        if (type === FILTER && _typeof(payload) === \"object\") {\n          var indexes = Object.entries(branch.indexes);\n          var accessedIndexes = [];\n          var indexAttrs = [];\n          indexes.forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                attr = _ref2[0],\n                index = _ref2[1];\n\n            if (clauseFiltersByAttribute(clause, attr)) {\n              /**\n               * Payload specified an indexed attribute. Use index\n               * to potentially decrease amount of accessed rows.\n               */\n              if (index.hasOwnProperty(payload[attr])) {\n                accessedIndexes.push(index[payload[attr]]);\n                indexAttrs.push(attr);\n              }\n            }\n          });\n          /**\n           * Calculate set of unique PK values corresponding to each\n           * foreign key's attribute value. Then retrieve all those rows.\n           */\n\n          if (accessedIndexes.length) {\n            var lastIndex = accessedIndexes.pop();\n            var indexedIds = accessedIndexes.reduce(function (result, index) {\n              var indexSet = new Set(index);\n              return result.filter(Set.prototype.has, indexSet);\n            }, lastIndex);\n\n            var _remainingPayload = Object.keys(payload).reduce(function (withoutIndexAttrs, filterAttr) {\n              if (!indexAttrs.includes(filterAttr)) {\n                withoutIndexAttrs[filterAttr] = payload[filterAttr];\n              }\n\n              return withoutIndexAttrs;\n            }, {});\n\n            if (Object.keys(_remainingPayload).length) {\n              /**\n               * Payload has additional, non-indexed columns.\n               * Filter indexed rows by remaining payload (if any were found).\n               */\n              return reducer(_this2.accessIds(branch, indexedIds), _objectSpread(_objectSpread({}, clause), {}, {\n                payload: _remainingPayload\n              }));\n            }\n            /**\n             * No need to filter these rows any further.\n             * The used indexes satisfy this clause's conditions.\n             */\n\n\n            return _this2.accessIds(branch, indexedIds);\n          }\n        } // Give up optimization: Retrieve all rows (full table scan).\n\n\n        return reducer(_this2.accessList(branch), clause);\n      }\n\n      switch (type) {\n        case FILTER:\n          {\n            return filter(rows, payload);\n          }\n\n        case EXCLUDE:\n          {\n            return reject(rows, payload);\n          }\n\n        case ORDER_BY:\n          {\n            var _payload = _slicedToArray(payload, 2),\n                iteratees = _payload[0],\n                orders = _payload[1];\n\n            return orderBy(rows, iteratees, normalizeOrders(orders));\n          }\n\n        default:\n          return rows;\n      }\n    };\n\n    return optimallyOrderedClauses.reduce(reducer, undefined);\n  }\n  /**\n   * Returns the data structure including a new object `entry`\n   * @param  {Object} tx - transaction info\n   * @param  {Object} branch - the data structure state\n   * @param  {Object} entry - the object to insert\n   * @return {Object} an object with two keys: `state` and `created`.\n   *                  `state` is the new table state and `created` is the\n   *                  row that was created.\n   */\n  ;\n\n  _proto.insert = function insert(tx, branch, entry) {\n    var _ops$batch$merge3;\n\n    var batchToken = tx.batchToken,\n        withMutations = tx.withMutations;\n    var hasId = entry.hasOwnProperty(this.idAttribute);\n    var workingState = branch; // This will not affect string id's.\n\n    var _idSequencer = idSequencer(this.getMaxId(branch), entry[this.idAttribute]),\n        _idSequencer2 = _slicedToArray(_idSequencer, 2),\n        newMaxId = _idSequencer2[0],\n        id = _idSequencer2[1];\n\n    workingState = this.setMaxId(tx, branch, newMaxId);\n    var finalEntry = hasId ? entry : ops.batch.set(batchToken, this.idAttribute, id, entry);\n    var indexesToAppendTo = Object.keys(workingState.indexes).filter(function (fkAttr) {\n      return entry.hasOwnProperty(fkAttr) && entry[fkAttr] !== null;\n    }).map(function (fkAttr) {\n      return [fkAttr, entry[fkAttr]];\n    });\n\n    if (withMutations) {\n      ops.mutable.push(id, workingState[this.arrName]);\n      ops.mutable.set(id, finalEntry, workingState[this.mapName]); // add id to indexes\n\n      indexesToAppendTo.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            attr = _ref4[0],\n            value = _ref4[1];\n\n        var attrIndex = workingState.indexes[attr];\n\n        if (attrIndex.hasOwnProperty(value)) {\n          ops.mutable.push(id, attrIndex[value]);\n        } else {\n          ops.mutable.set(value, [id], attrIndex);\n        }\n      });\n      return {\n        state: workingState,\n        created: finalEntry\n      };\n    }\n\n    var nextIndexes = ops.batch.merge(batchToken, indexesToAppendTo.reduce(function (indexMap, _ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          attr = _ref6[0],\n          value = _ref6[1];\n\n      indexMap[attr] = ops.batch.merge(batchToken, _defineProperty({}, value, ops.batch.push(batchToken, id, indexMap[attr][value] || [])), indexMap[attr]);\n      return indexMap;\n    }, _objectSpread({}, workingState.indexes)), workingState.indexes);\n    var nextState = ops.batch.merge(batchToken, (_ops$batch$merge3 = {}, _defineProperty(_ops$batch$merge3, this.arrName, ops.batch.push(batchToken, id, workingState[this.arrName])), _defineProperty(_ops$batch$merge3, this.mapName, ops.batch.merge(batchToken, _defineProperty({}, id, finalEntry), workingState[this.mapName])), _defineProperty(_ops$batch$merge3, \"indexes\", nextIndexes), _ops$batch$merge3), workingState);\n    return {\n      state: nextState,\n      created: finalEntry\n    };\n  }\n  /**\n   * Returns the data structure with objects where `rows`\n   * are merged with `mergeObj`.\n   *\n   * @param  {Object} tx - transaction info\n   * @param  {Object} branch - the data structure state\n   * @param  {Object[]} rows - rows to update\n   * @param  {Object} mergeObj - The object to merge with each row.\n   * @return {Object}\n   */\n  ;\n\n  _proto.update = function update(tx, branch, rows, mergeObj) {\n    var _this3 = this,\n        _ops$batch$merge6;\n\n    var batchToken = tx.batchToken,\n        withMutations = tx.withMutations;\n\n    var mergeObjInto = function mergeObjInto(row) {\n      var merge = withMutations ? ops.mutable.merge : ops.batch.merge(batchToken);\n      return merge(mergeObj, row);\n    };\n\n    var set = withMutations ? ops.mutable.set : ops.batch.set(batchToken);\n    var indexedAttrs = Object.keys(branch.indexes).filter(function (attr) {\n      return mergeObj.hasOwnProperty(attr);\n    });\n    var indexIdsToAdd = [];\n    var indexIdsToDelete = [];\n    var nextMap = rows.reduce(function (map, row) {\n      var prevAttrValues = indexedAttrs.reduce(function (valueMap, attr) {\n        return _objectSpread(_objectSpread({}, valueMap), {}, _defineProperty({}, attr, row[attr]));\n      }, {});\n      var result = mergeObjInto(row);\n      var nextAttrValues = indexedAttrs.reduce(function (valueMap, attr) {\n        return _objectSpread(_objectSpread({}, valueMap), {}, _defineProperty({}, attr, result[attr]));\n      }, {});\n      var id = result[_this3.idAttribute];\n      var nextRow = set(id, result, map);\n      indexedAttrs.forEach(function (attr) {\n        var prevValue = prevAttrValues[attr];\n        var nextValue = nextAttrValues[attr];\n\n        if (prevValue === nextValue) {\n          // attribute has not changed, no need to update any index\n          return;\n        }\n\n        if (prevValue !== null && typeof prevValue !== \"undefined\") {\n          // remove id from attribute's index for its old value\n          indexIdsToDelete.push([attr, prevValue, id]);\n        }\n\n        if (nextValue !== null) {\n          // add id to attribute's index for its new value\n          indexIdsToAdd.push([attr, nextValue, id]);\n        }\n      });\n      return nextRow;\n    }, branch[this.mapName]);\n    var nextIndexes = branch.indexes;\n\n    if (withMutations) {\n      indexIdsToDelete.forEach(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 3),\n            attr = _ref8[0],\n            value = _ref8[1],\n            id = _ref8[2];\n\n        var arr = nextIndexes[attr][value];\n        var idx = arr.indexOf(id);\n        ops.mutable.splice(idx, 1, [], arr);\n      });\n      indexIdsToAdd.forEach(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 3),\n            attr = _ref10[0],\n            value = _ref10[1],\n            id = _ref10[2];\n\n        ops.mutable.push(id, nextIndexes[attr][value]);\n      });\n    } else {\n      if (indexIdsToAdd.length) {\n        nextIndexes = ops.batch.merge(batchToken, indexIdsToAdd.reduce(function (indexMap, _ref11) {\n          var _ref12 = _slicedToArray(_ref11, 3),\n              attr = _ref12[0],\n              value = _ref12[1],\n              id = _ref12[2];\n\n          indexMap[attr] = ops.batch.merge(batchToken, _defineProperty({}, value, ops.batch.push(batchToken, id, indexMap[attr][value] || [])), indexMap[attr]);\n          return indexMap;\n        }, _objectSpread({}, nextIndexes)), nextIndexes);\n      }\n\n      if (indexIdsToDelete.length) {\n        nextIndexes = ops.batch.merge(batchToken, indexIdsToDelete.reduce(function (indexMap, _ref13) {\n          var _ref14 = _slicedToArray(_ref13, 3),\n              attr = _ref14[0],\n              value = _ref14[1],\n              id = _ref14[2];\n\n          indexMap[attr] = ops.batch.merge(batchToken, _defineProperty({}, value, ops.batch.filter(batchToken, function (rowId) {\n            return rowId !== id;\n          }, indexMap[attr][value])), indexMap[attr]);\n          return indexMap;\n        }, _objectSpread({}, nextIndexes)), nextIndexes);\n      }\n    }\n\n    return ops.batch.merge(batchToken, (_ops$batch$merge6 = {}, _defineProperty(_ops$batch$merge6, this.mapName, nextMap), _defineProperty(_ops$batch$merge6, \"indexes\", nextIndexes), _ops$batch$merge6), branch);\n  }\n  /**\n   * Returns the data structure without rows `rows`.\n   * @param  {Object} tx - transaction info\n   * @param  {Object} branch - the data structure state\n   * @param  {Object[]} rows - rows to update\n   * @return {Object} the data structure without ids in `idsToDelete`.\n   */\n  ;\n\n  _proto[\"delete\"] = function _delete(tx, branch, rows) {\n    var _this4 = this,\n        _ops$batch$merge7;\n\n    var batchToken = tx.batchToken,\n        withMutations = tx.withMutations;\n    var arrName = this.arrName,\n        mapName = this.mapName;\n    var arr = branch[arrName];\n    var idsToDelete = rows.map(function (row) {\n      return row[_this4.idAttribute];\n    });\n\n    if (withMutations) {\n      idsToDelete.forEach(function (id) {\n        var idx = arr.indexOf(id);\n        ops.mutable.splice(idx, 1, [], arr);\n        ops.mutable.omit(id, branch[mapName]);\n      }); // delete ids from all indexes\n\n      Object.values(branch.indexes).forEach(function (attrIndex) {\n        return Object.values(attrIndex).forEach(function (valueIndex) {\n          return idsToDelete.forEach(function (id) {\n            var idx = valueIndex.indexOf(id);\n\n            if (idx !== -1) {\n              ops.mutable.splice(idx, 1, [], valueIndex);\n            }\n          });\n        });\n      });\n      return branch;\n    }\n\n    var nextIndexes = ops.batch.merge(batchToken, Object.entries(branch.indexes).reduce(function (indexMap, _ref15) {\n      var _ref16 = _slicedToArray(_ref15, 2),\n          attr = _ref16[0],\n          attrIndex = _ref16[1];\n\n      indexMap[attr] = ops.batch.merge(batchToken, Object.entries(attrIndex).reduce(function (attrIndexMap, _ref17) {\n        var _ref18 = _slicedToArray(_ref17, 2),\n            value = _ref18[0],\n            valueIndex = _ref18[1];\n\n        attrIndexMap[value] = ops.batch.filter(batchToken, function (id) {\n          return !idsToDelete.includes(id);\n        }, valueIndex);\n        return attrIndexMap;\n      }, _objectSpread({}, indexMap[attr])), indexMap[attr]);\n      return indexMap;\n    }, _objectSpread({}, branch.indexes)), branch.indexes);\n    return ops.batch.merge(batchToken, (_ops$batch$merge7 = {}, _defineProperty(_ops$batch$merge7, arrName, ops.batch.filter(batchToken, function (id) {\n      return !idsToDelete.includes(id);\n    }, branch[arrName])), _defineProperty(_ops$batch$merge7, mapName, ops.batch.omit(batchToken, idsToDelete, branch[mapName])), _defineProperty(_ops$batch$merge7, \"indexes\", ops.batch.merge(batchToken, nextIndexes, branch.indexes)), _ops$batch$merge7), branch);\n  };\n\n  return Table;\n}();\nexport default Table;","map":{"version":3,"names":["_slicedToArray","_typeof","_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","ops","orderBy","reject","sortBy","EXCLUDE","FILTER","ORDER_BY","clauseFiltersByAttribute","clauseReducesResultSetSize","DEFAULT_TABLE_OPTIONS","idAttribute","arrName","mapName","fields","idSequencer","_currMax","userPassedId","currMax","newMax","newId","undefined","Math","max","normalizeOrders","orders","convert","order","includes","Array","isArray","map","Table","userOpts","assign","_proto","prototype","accessId","branch","id","accessIds","ids","idExists","hasOwnProperty","accessIdList","accessList","getMaxId","getMeta","setMaxId","tx","newMaxId","setMeta","nextId","getEmptyState","_pkIndex","_this","pkIndex","attrIndexes","attr","index","reduce","indexes","meta","value","batchToken","withMutations","res","mutable","setIn","batch","query","clauses","_this2","optimallyOrderedClauses","clause","reducer","rows","type","payload","remainingPayload","withoutPkAttr","filterAttr","entries","accessedIndexes","indexAttrs","_ref","_ref2","lastIndex","pop","indexedIds","result","indexSet","Set","has","_remainingPayload","withoutIndexAttrs","_payload","iteratees","insert","entry","_ops$batch$merge3","hasId","workingState","_idSequencer","_idSequencer2","finalEntry","set","indexesToAppendTo","fkAttr","_ref3","_ref4","attrIndex","state","created","nextIndexes","merge","indexMap","_ref5","_ref6","nextState","update","mergeObj","_this3","_ops$batch$merge6","mergeObjInto","row","indexedAttrs","indexIdsToAdd","indexIdsToDelete","nextMap","prevAttrValues","valueMap","nextAttrValues","nextRow","prevValue","nextValue","_ref7","_ref8","arr","idx","indexOf","splice","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","rowId","_delete","_this4","_ops$batch$merge7","idsToDelete","omit","values","valueIndex","_ref15","_ref16","attrIndexMap","_ref17","_ref18"],"sources":["/Users/developer/task/task3/node_modules/redux-orm/es/db/Table.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport ops from \"immutable-ops\";\nimport filter from \"lodash/filter\";\nimport orderBy from \"lodash/orderBy\";\nimport reject from \"lodash/reject\";\nimport sortBy from \"lodash/sortBy\";\nimport { EXCLUDE, FILTER, ORDER_BY } from \"../constants\";\nimport { clauseFiltersByAttribute, clauseReducesResultSetSize } from \"../utils\";\nvar DEFAULT_TABLE_OPTIONS = {\n  idAttribute: \"id\",\n  arrName: \"items\",\n  mapName: \"itemsById\",\n  fields: {}\n};\n/**\n * @private\n * @param {*} _currMax - the current max id\n * @param {*} userPassedId - the new id passed to the create action\n *\n * Both may be undefined. The current max id in the case that this is the first Model\n * being created, and the new id if the id was not explicitly passed to the\n * database.\n *\n * @return {Array} the new max id and the id to use to create the new row\n *\n * If the id's are strings, the id must be passed explicitly every time.\n * In this case, the current max id will remain `NaN` due to `Math.max`, but that's fine.\n */\n\nfunction idSequencer(_currMax, userPassedId) {\n  var currMax = _currMax;\n  var newMax;\n  var newId;\n\n  if (currMax === undefined) {\n    currMax = -1;\n  }\n\n  if (userPassedId === undefined) {\n    newMax = currMax + 1;\n    newId = newMax;\n  } else {\n    newMax = Math.max(currMax + 1, userPassedId);\n    newId = userPassedId;\n  }\n\n  return [newMax, // new max id\n  newId // id to use for row creation\n  ];\n}\n/**\n * Adapt order directions array to @{lodash.orderBy} API.\n *\n * @private\n *\n * @param {Array<Boolean|'asc'|'desc'>} orders? - an array of optional order query directions as provided to {@Link {QuerySet.orderBy}}\n * @return {Array<'asc'|'desc'>|undefined} A normalized ordering array or undefined if none was provided.\n */\n\n\nfunction normalizeOrders(orders) {\n  if (orders === undefined) {\n    return undefined;\n  }\n\n  var convert = function convert(order) {\n    if ([\"desc\", false].includes(order)) {\n      return \"desc\";\n    }\n\n    return \"asc\";\n  };\n\n  return Array.isArray(orders) ? orders.map(convert) : convert(orders);\n}\n/**\n * Handles the underlying data structure for a {@link Model} class.\n * @private\n */\n\n\nexport var Table = /*#__PURE__*/function () {\n  /**\n   * Creates a new {@link Table} instance.\n   * @param  {Object} userOpts - options to use.\n   * @param  {string} [userOpts.idAttribute=id] - the id attribute of the entity.\n   * @param  {string} [userOpts.arrName=items] - the state attribute where an array of\n   *                                             entity id's are stored\n   * @param  {string} [userOpts.mapName=itemsById] - the state attribute where the entity objects\n   *                                                 are stored in a id to entity object\n   *                                                 map.\n   * @param  {string} [userOpts.fields={}] - mapping of field key to {@link Field} object\n   */\n  function Table(userOpts) {\n    Object.assign(this, DEFAULT_TABLE_OPTIONS, userOpts);\n  }\n  /**\n   * Returns a reference to the object at index `id`\n   * in state `branch`.\n   *\n   * @param  {Object} branch - the state\n   * @param  {Number} id - the id of the object to get\n   * @return {Object|undefined} A reference to the raw object in the state or\n   *                            `undefined` if not found.\n   */\n\n\n  var _proto = Table.prototype;\n\n  _proto.accessId = function accessId(branch, id) {\n    return branch[this.mapName][id];\n  };\n\n  _proto.accessIds = function accessIds(branch, ids) {\n    var map = branch[this.mapName];\n    return ids.map(function (id) {\n      return map[id];\n    });\n  };\n\n  _proto.idExists = function idExists(branch, id) {\n    return branch[this.mapName].hasOwnProperty(id);\n  };\n\n  _proto.accessIdList = function accessIdList(branch) {\n    return branch[this.arrName];\n  };\n\n  _proto.accessList = function accessList(branch) {\n    return this.accessIds(branch, this.accessIdList(branch));\n  };\n\n  _proto.getMaxId = function getMaxId(branch) {\n    return this.getMeta(branch, \"maxId\");\n  };\n\n  _proto.setMaxId = function setMaxId(tx, branch, newMaxId) {\n    return this.setMeta(tx, branch, \"maxId\", newMaxId);\n  };\n\n  _proto.nextId = function nextId(id) {\n    return id + 1;\n  }\n  /**\n   * Returns the default state for the data structure.\n   * @return {Object} The default state for this {@link ORM} instance's data structure\n   */\n  ;\n\n  _proto.getEmptyState = function getEmptyState() {\n    var _pkIndex,\n        _this = this;\n\n    var pkIndex = (_pkIndex = {}, _defineProperty(_pkIndex, this.arrName, []), _defineProperty(_pkIndex, this.mapName, {}), _pkIndex);\n    var attrIndexes = Object.keys(this.fields).filter(function (attr) {\n      return attr !== _this.idAttribute;\n    }).filter(function (attr) {\n      return _this.fields[attr].index;\n    }).reduce(function (indexes, attr) {\n      return _objectSpread(_objectSpread({}, indexes), {}, _defineProperty({}, attr, {}));\n    }, {});\n    return _objectSpread(_objectSpread({}, pkIndex), {}, {\n      indexes: attrIndexes,\n      meta: {}\n    });\n  };\n\n  _proto.setMeta = function setMeta(tx, branch, key, value) {\n    var batchToken = tx.batchToken,\n        withMutations = tx.withMutations;\n\n    if (withMutations) {\n      var res = ops.mutable.setIn([\"meta\", key], value, branch);\n      return res;\n    }\n\n    return ops.batch.setIn(batchToken, [\"meta\", key], value, branch);\n  };\n\n  _proto.getMeta = function getMeta(branch, key) {\n    return branch.meta[key];\n  };\n\n  _proto.query = function query(branch, clauses) {\n    var _this2 = this;\n\n    if (clauses.length === 0) {\n      return this.accessList(branch);\n    }\n\n    var idAttribute = this.idAttribute;\n    var optimallyOrderedClauses = sortBy(clauses, function (clause) {\n      if (clauseFiltersByAttribute(clause, idAttribute)) {\n        return 1;\n      }\n\n      if (clauseReducesResultSetSize(clause)) {\n        return 2;\n      }\n\n      return 3;\n    });\n\n    var reducer = function reducer(rows, clause) {\n      var type = clause.type,\n          payload = clause.payload;\n\n      if (!rows) {\n        /**\n         * First time this reducer is called during query.\n         * This is where we apply query optimizations.\n         */\n        if (clauseFiltersByAttribute(clause, idAttribute)) {\n          /**\n           * Payload specified a primary key. Use PK index\n           * to look up the single row identified by the PK.\n           */\n          var id = payload[idAttribute];\n          var remainingPayload = Object.keys(payload).reduce(function (withoutPkAttr, filterAttr) {\n            if (filterAttr !== idAttribute) {\n              withoutPkAttr[filterAttr] = payload[filterAttr];\n            }\n\n            return withoutPkAttr;\n          }, {});\n          var ids = _this2.idExists(branch, id) ? [id] : [];\n\n          if (Object.keys(remainingPayload).length) {\n            /**\n             * Payload has additional, non-PK columns.\n             * Filter accessed row by remaining payload (if one was found).\n             */\n            return reducer(_this2.accessIds(branch, ids), _objectSpread(_objectSpread({}, clause), {}, {\n              payload: remainingPayload\n            }));\n          }\n          /**\n           * No need to filter these rows any further.\n           * The primary key value satisfies this clause's conditions.\n           */\n\n\n          return _this2.accessIds(branch, ids);\n        }\n\n        if (type === FILTER && _typeof(payload) === \"object\") {\n          var indexes = Object.entries(branch.indexes);\n          var accessedIndexes = [];\n          var indexAttrs = [];\n          indexes.forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                attr = _ref2[0],\n                index = _ref2[1];\n\n            if (clauseFiltersByAttribute(clause, attr)) {\n              /**\n               * Payload specified an indexed attribute. Use index\n               * to potentially decrease amount of accessed rows.\n               */\n              if (index.hasOwnProperty(payload[attr])) {\n                accessedIndexes.push(index[payload[attr]]);\n                indexAttrs.push(attr);\n              }\n            }\n          });\n          /**\n           * Calculate set of unique PK values corresponding to each\n           * foreign key's attribute value. Then retrieve all those rows.\n           */\n\n          if (accessedIndexes.length) {\n            var lastIndex = accessedIndexes.pop();\n            var indexedIds = accessedIndexes.reduce(function (result, index) {\n              var indexSet = new Set(index);\n              return result.filter(Set.prototype.has, indexSet);\n            }, lastIndex);\n\n            var _remainingPayload = Object.keys(payload).reduce(function (withoutIndexAttrs, filterAttr) {\n              if (!indexAttrs.includes(filterAttr)) {\n                withoutIndexAttrs[filterAttr] = payload[filterAttr];\n              }\n\n              return withoutIndexAttrs;\n            }, {});\n\n            if (Object.keys(_remainingPayload).length) {\n              /**\n               * Payload has additional, non-indexed columns.\n               * Filter indexed rows by remaining payload (if any were found).\n               */\n              return reducer(_this2.accessIds(branch, indexedIds), _objectSpread(_objectSpread({}, clause), {}, {\n                payload: _remainingPayload\n              }));\n            }\n            /**\n             * No need to filter these rows any further.\n             * The used indexes satisfy this clause's conditions.\n             */\n\n\n            return _this2.accessIds(branch, indexedIds);\n          }\n        } // Give up optimization: Retrieve all rows (full table scan).\n\n\n        return reducer(_this2.accessList(branch), clause);\n      }\n\n      switch (type) {\n        case FILTER:\n          {\n            return filter(rows, payload);\n          }\n\n        case EXCLUDE:\n          {\n            return reject(rows, payload);\n          }\n\n        case ORDER_BY:\n          {\n            var _payload = _slicedToArray(payload, 2),\n                iteratees = _payload[0],\n                orders = _payload[1];\n\n            return orderBy(rows, iteratees, normalizeOrders(orders));\n          }\n\n        default:\n          return rows;\n      }\n    };\n\n    return optimallyOrderedClauses.reduce(reducer, undefined);\n  }\n  /**\n   * Returns the data structure including a new object `entry`\n   * @param  {Object} tx - transaction info\n   * @param  {Object} branch - the data structure state\n   * @param  {Object} entry - the object to insert\n   * @return {Object} an object with two keys: `state` and `created`.\n   *                  `state` is the new table state and `created` is the\n   *                  row that was created.\n   */\n  ;\n\n  _proto.insert = function insert(tx, branch, entry) {\n    var _ops$batch$merge3;\n\n    var batchToken = tx.batchToken,\n        withMutations = tx.withMutations;\n    var hasId = entry.hasOwnProperty(this.idAttribute);\n    var workingState = branch; // This will not affect string id's.\n\n    var _idSequencer = idSequencer(this.getMaxId(branch), entry[this.idAttribute]),\n        _idSequencer2 = _slicedToArray(_idSequencer, 2),\n        newMaxId = _idSequencer2[0],\n        id = _idSequencer2[1];\n\n    workingState = this.setMaxId(tx, branch, newMaxId);\n    var finalEntry = hasId ? entry : ops.batch.set(batchToken, this.idAttribute, id, entry);\n    var indexesToAppendTo = Object.keys(workingState.indexes).filter(function (fkAttr) {\n      return entry.hasOwnProperty(fkAttr) && entry[fkAttr] !== null;\n    }).map(function (fkAttr) {\n      return [fkAttr, entry[fkAttr]];\n    });\n\n    if (withMutations) {\n      ops.mutable.push(id, workingState[this.arrName]);\n      ops.mutable.set(id, finalEntry, workingState[this.mapName]); // add id to indexes\n\n      indexesToAppendTo.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            attr = _ref4[0],\n            value = _ref4[1];\n\n        var attrIndex = workingState.indexes[attr];\n\n        if (attrIndex.hasOwnProperty(value)) {\n          ops.mutable.push(id, attrIndex[value]);\n        } else {\n          ops.mutable.set(value, [id], attrIndex);\n        }\n      });\n      return {\n        state: workingState,\n        created: finalEntry\n      };\n    }\n\n    var nextIndexes = ops.batch.merge(batchToken, indexesToAppendTo.reduce(function (indexMap, _ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          attr = _ref6[0],\n          value = _ref6[1];\n\n      indexMap[attr] = ops.batch.merge(batchToken, _defineProperty({}, value, ops.batch.push(batchToken, id, indexMap[attr][value] || [])), indexMap[attr]);\n      return indexMap;\n    }, _objectSpread({}, workingState.indexes)), workingState.indexes);\n    var nextState = ops.batch.merge(batchToken, (_ops$batch$merge3 = {}, _defineProperty(_ops$batch$merge3, this.arrName, ops.batch.push(batchToken, id, workingState[this.arrName])), _defineProperty(_ops$batch$merge3, this.mapName, ops.batch.merge(batchToken, _defineProperty({}, id, finalEntry), workingState[this.mapName])), _defineProperty(_ops$batch$merge3, \"indexes\", nextIndexes), _ops$batch$merge3), workingState);\n    return {\n      state: nextState,\n      created: finalEntry\n    };\n  }\n  /**\n   * Returns the data structure with objects where `rows`\n   * are merged with `mergeObj`.\n   *\n   * @param  {Object} tx - transaction info\n   * @param  {Object} branch - the data structure state\n   * @param  {Object[]} rows - rows to update\n   * @param  {Object} mergeObj - The object to merge with each row.\n   * @return {Object}\n   */\n  ;\n\n  _proto.update = function update(tx, branch, rows, mergeObj) {\n    var _this3 = this,\n        _ops$batch$merge6;\n\n    var batchToken = tx.batchToken,\n        withMutations = tx.withMutations;\n\n    var mergeObjInto = function mergeObjInto(row) {\n      var merge = withMutations ? ops.mutable.merge : ops.batch.merge(batchToken);\n      return merge(mergeObj, row);\n    };\n\n    var set = withMutations ? ops.mutable.set : ops.batch.set(batchToken);\n    var indexedAttrs = Object.keys(branch.indexes).filter(function (attr) {\n      return mergeObj.hasOwnProperty(attr);\n    });\n    var indexIdsToAdd = [];\n    var indexIdsToDelete = [];\n    var nextMap = rows.reduce(function (map, row) {\n      var prevAttrValues = indexedAttrs.reduce(function (valueMap, attr) {\n        return _objectSpread(_objectSpread({}, valueMap), {}, _defineProperty({}, attr, row[attr]));\n      }, {});\n      var result = mergeObjInto(row);\n      var nextAttrValues = indexedAttrs.reduce(function (valueMap, attr) {\n        return _objectSpread(_objectSpread({}, valueMap), {}, _defineProperty({}, attr, result[attr]));\n      }, {});\n      var id = result[_this3.idAttribute];\n      var nextRow = set(id, result, map);\n      indexedAttrs.forEach(function (attr) {\n        var prevValue = prevAttrValues[attr];\n        var nextValue = nextAttrValues[attr];\n\n        if (prevValue === nextValue) {\n          // attribute has not changed, no need to update any index\n          return;\n        }\n\n        if (prevValue !== null && typeof prevValue !== \"undefined\") {\n          // remove id from attribute's index for its old value\n          indexIdsToDelete.push([attr, prevValue, id]);\n        }\n\n        if (nextValue !== null) {\n          // add id to attribute's index for its new value\n          indexIdsToAdd.push([attr, nextValue, id]);\n        }\n      });\n      return nextRow;\n    }, branch[this.mapName]);\n    var nextIndexes = branch.indexes;\n\n    if (withMutations) {\n      indexIdsToDelete.forEach(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 3),\n            attr = _ref8[0],\n            value = _ref8[1],\n            id = _ref8[2];\n\n        var arr = nextIndexes[attr][value];\n        var idx = arr.indexOf(id);\n        ops.mutable.splice(idx, 1, [], arr);\n      });\n      indexIdsToAdd.forEach(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 3),\n            attr = _ref10[0],\n            value = _ref10[1],\n            id = _ref10[2];\n\n        ops.mutable.push(id, nextIndexes[attr][value]);\n      });\n    } else {\n      if (indexIdsToAdd.length) {\n        nextIndexes = ops.batch.merge(batchToken, indexIdsToAdd.reduce(function (indexMap, _ref11) {\n          var _ref12 = _slicedToArray(_ref11, 3),\n              attr = _ref12[0],\n              value = _ref12[1],\n              id = _ref12[2];\n\n          indexMap[attr] = ops.batch.merge(batchToken, _defineProperty({}, value, ops.batch.push(batchToken, id, indexMap[attr][value] || [])), indexMap[attr]);\n          return indexMap;\n        }, _objectSpread({}, nextIndexes)), nextIndexes);\n      }\n\n      if (indexIdsToDelete.length) {\n        nextIndexes = ops.batch.merge(batchToken, indexIdsToDelete.reduce(function (indexMap, _ref13) {\n          var _ref14 = _slicedToArray(_ref13, 3),\n              attr = _ref14[0],\n              value = _ref14[1],\n              id = _ref14[2];\n\n          indexMap[attr] = ops.batch.merge(batchToken, _defineProperty({}, value, ops.batch.filter(batchToken, function (rowId) {\n            return rowId !== id;\n          }, indexMap[attr][value])), indexMap[attr]);\n          return indexMap;\n        }, _objectSpread({}, nextIndexes)), nextIndexes);\n      }\n    }\n\n    return ops.batch.merge(batchToken, (_ops$batch$merge6 = {}, _defineProperty(_ops$batch$merge6, this.mapName, nextMap), _defineProperty(_ops$batch$merge6, \"indexes\", nextIndexes), _ops$batch$merge6), branch);\n  }\n  /**\n   * Returns the data structure without rows `rows`.\n   * @param  {Object} tx - transaction info\n   * @param  {Object} branch - the data structure state\n   * @param  {Object[]} rows - rows to update\n   * @return {Object} the data structure without ids in `idsToDelete`.\n   */\n  ;\n\n  _proto[\"delete\"] = function _delete(tx, branch, rows) {\n    var _this4 = this,\n        _ops$batch$merge7;\n\n    var batchToken = tx.batchToken,\n        withMutations = tx.withMutations;\n    var arrName = this.arrName,\n        mapName = this.mapName;\n    var arr = branch[arrName];\n    var idsToDelete = rows.map(function (row) {\n      return row[_this4.idAttribute];\n    });\n\n    if (withMutations) {\n      idsToDelete.forEach(function (id) {\n        var idx = arr.indexOf(id);\n        ops.mutable.splice(idx, 1, [], arr);\n        ops.mutable.omit(id, branch[mapName]);\n      }); // delete ids from all indexes\n\n      Object.values(branch.indexes).forEach(function (attrIndex) {\n        return Object.values(attrIndex).forEach(function (valueIndex) {\n          return idsToDelete.forEach(function (id) {\n            var idx = valueIndex.indexOf(id);\n\n            if (idx !== -1) {\n              ops.mutable.splice(idx, 1, [], valueIndex);\n            }\n          });\n        });\n      });\n      return branch;\n    }\n\n    var nextIndexes = ops.batch.merge(batchToken, Object.entries(branch.indexes).reduce(function (indexMap, _ref15) {\n      var _ref16 = _slicedToArray(_ref15, 2),\n          attr = _ref16[0],\n          attrIndex = _ref16[1];\n\n      indexMap[attr] = ops.batch.merge(batchToken, Object.entries(attrIndex).reduce(function (attrIndexMap, _ref17) {\n        var _ref18 = _slicedToArray(_ref17, 2),\n            value = _ref18[0],\n            valueIndex = _ref18[1];\n\n        attrIndexMap[value] = ops.batch.filter(batchToken, function (id) {\n          return !idsToDelete.includes(id);\n        }, valueIndex);\n        return attrIndexMap;\n      }, _objectSpread({}, indexMap[attr])), indexMap[attr]);\n      return indexMap;\n    }, _objectSpread({}, branch.indexes)), branch.indexes);\n    return ops.batch.merge(batchToken, (_ops$batch$merge7 = {}, _defineProperty(_ops$batch$merge7, arrName, ops.batch.filter(batchToken, function (id) {\n      return !idsToDelete.includes(id);\n    }, branch[arrName])), _defineProperty(_ops$batch$merge7, mapName, ops.batch.omit(batchToken, idsToDelete, branch[mapName])), _defineProperty(_ops$batch$merge7, \"indexes\", ops.batch.merge(batchToken, nextIndexes, branch.indexes)), _ops$batch$merge7), branch);\n  };\n\n  return Table;\n}();\nexport default Table;"],"mappings":"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"},"metadata":{},"sourceType":"module"}