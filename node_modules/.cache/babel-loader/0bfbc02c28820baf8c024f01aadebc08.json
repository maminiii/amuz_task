{"ast":null,"code":"import _construct from \"@babel/runtime/helpers/construct\";\nimport Attribute from \"./Attribute\";\nimport ForeignKey from \"./ForeignKey\";\nimport ManyToMany from \"./ManyToMany\";\nimport OneToOne from \"./OneToOne\";\n/**\n * Contains the logic for how fields on {@link Model}s work\n * and which descriptors must be installed.\n *\n * If your goal is to define fields on a Model class,\n * please use the more convenient methods {@link attr},\n * {@link fk}, {@link many} and {@link oneToOne}.\n *\n * @module fields\n */\n\n/**\n * Defines a value attribute on the model.\n * Though not required, it is recommended to define this for each non-foreign key you wish to use.\n * Getters and setters need to be defined on each Model\n * instantiation for undeclared data fields, which is slower.\n * You can use the optional `getDefault` parameter to fill in unpassed values\n * to {@link Model.create}, such as for generating ID's with UUID:\n *\n * ```javascript\n * import getUUID from 'your-uuid-package-of-choice';\n *\n * fields = {\n *   id: attr({ getDefault: () => getUUID() }),\n *   title: attr(),\n * }\n * ```\n *\n * @param  {Object} [opts]\n * @param {Function} [opts.getDefault] - If you give a function here, its return\n *                                       value from calling with zero arguments will\n *                                       be used as the value when creating a new Model\n *                                       instance with {@link Model#create} if the field\n *                                       value is not passed.\n * @return {Attribute}\n */\n\nfunction attr(opts) {\n  return new Attribute(opts);\n}\n/**\n * Defines a foreign key on a model, which points\n * to a single entity on another model.\n *\n * You can pass arguments as either a single object,\n * or two arguments.\n *\n * If you pass two arguments, the first one is the name\n * of the Model the foreign key is pointing to, and\n * the second one is an optional related name, which will\n * be used to access the Model the foreign key\n * is being defined from, from the target Model.\n *\n * If the related name is not passed, it will be set as\n * `${toModelName}Set`.\n *\n * If you pass an object to `fk`, it has to be in the form\n *\n * ```javascript\n * fields = {\n *   author: fk({ to: 'Author', relatedName: 'books' })\n * }\n * ```\n *\n * Which is equal to\n *\n * ```javascript\n * fields = {\n *   author: fk('Author', 'books'),\n * }\n * ```\n *\n * @param {string|Class<Model>|Object} options - The target Model class, its `modelName`\n *                                               attribute or an options object that\n *                                               contains either as the `to` key.\n * @param {string|Class<Model>} options.to - The target Model class or its `modelName` attribute.\n * @param {string} [options.as] - Name for the new accessor defined for this field. If you don't\n *                                supply this, the key that this field is defined under will be\n *                                overridden.\n * @param {string} [options.relatedName] - The property name that will be used to access\n *                                         a QuerySet for all source models that reference\n *                                         the respective target Model's instance.\n * @param {string} [relatedName] - If you didn't pass an object as the first argument,\n *                                 this is the property name that will be used to\n *                                 access a QuerySet for all source models that reference\n *                                 the respective target Model's instance.\n * @return {ForeignKey}\n */\n\n\nfunction fk() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(ForeignKey, args);\n}\n/**\n * Defines a many-to-many relationship between\n * this (source) and another (target) model.\n *\n * The relationship is modeled with an extra model called the through model.\n * The through model has foreign keys to both the source and target models.\n *\n * You can define your own through model if you want to associate more information\n * to the relationship. A custom through model must have at least two foreign keys,\n * one pointing to the source Model, and one pointing to the target Model.\n *\n * Like `fk`, this function accepts one or two string arguments specifying the other\n * Model and the related name, or a single object argument that allows you to pass\n * a custom through model.\n *\n * If you have more than one foreign key pointing to a source or target Model in the\n * through Model, you must pass the option `throughFields`, which is an array of two\n * strings, where the strings are the field names that identify the foreign keys to\n * be used for the many-to-many relationship. Redux-ORM will figure out which field name\n * points to which model by checking the \"through model\" definition.\n *\n * ```javascript\n * class Authorship extends Model {}\n * Authorship.modelName = 'Authorship';\n * Authorship.fields = {\n *   author: fk('Author', 'authorships'),\n *   book: fk('Book', 'authorships'),\n * };\n *\n * class Author extends Model {}\n * Author.modelName = 'Author';\n * Author.fields = {\n *   books: many({\n *     to: 'Book',\n *     relatedName: 'authors',\n *     through: 'Authorship',\n *\n *     // here this is optional: Redux-ORM can figure\n *     // out the through fields itself since the two\n *     // foreign key fields point to different Models\n *     throughFields: ['author', 'book'],\n *   })\n * };\n *\n * class Book extends Model {}\n * Book.modelName = 'Book';\n * ```\n *\n * You should only define the many-to-many relationship on one side. In the\n * above case of Authors to Books through Authorships, the relationship is\n * defined only on the Author model.\n *\n * @param {string|Class<Model>|Object} options - The target Model class, its `modelName`\n *                                               attribute or an options object that\n *                                               contains either as the `to` key.\n * @param {string|Class<Model>} options.to - The target Model class or its `modelName` attribute.\n * @param {string} [options.as] - Name for the new accessor defined for this field. If you don't\n *                                supply this, the key that this field is defined under will be\n *                                overridden.\n * @param {string|Class<Model>} [options.through] - The through Model class or its `modelName`\n *                                                  attribute. It must declare at least one\n *                                                  foreign key to both source and target models.\n *                                                  If not supplied, Redux-ORM will generate one.\n * @param {string[]} [options.throughFields] - Must be supplied only when a custom through\n *                                             Model has more than one foreign key pointing to\n *                                             either the source or target mode. In this case\n *                                             Redux-ORM can't figure out the correct fields for\n *                                             you, you must provide them. The supplied array should\n *                                             have two elements that are the field names for the\n *                                             through fields you want to declare the many-to-many\n *                                             relationship with. The order doesn't matter;\n *                                             Redux-ORM will figure out which field points to\n *                                             the source Model and which to the target Model.\n * @param {string} [options.relatedName] - The attribute used to access a QuerySet for all\n *                                         source models that reference the respective target\n *                                         Model's instance.\n * @param {string} [relatedName] - If you didn't pass an object as the first argument,\n *                                 this is the property name that will be used to\n *                                 access a QuerySet for all source models that reference\n *                                 the respective target Model's instance.\n * @return {ManyToMany}\n */\n\n\nfunction many() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return _construct(ManyToMany, args);\n}\n/**\n * Defines a one-to-one relationship. In database terms, this is a foreign key with the\n * added restriction that only one entity can point to single target entity.\n *\n * The arguments are the same as with `fk`. If `relatedName` is not supplied,\n * the source model name in lowercase will be used. Note that with the one-to-one\n * relationship, the `relatedName` should be in singular, not plural.\n *\n *\n * @param {string|Class<Model>|Object} options - The target Model class, its `modelName`\n *                                               attribute or an options object that\n *                                               contains either as the `to` key.\n * @param {string|Class<Model>} options.to - The target Model class or its `modelName` attribute.\n * @param {string} [options.as] - Name for the new accessor defined for this field. If you don't\n *                                supply this, the key that this field is defined under will be\n *                                overridden.\n * @param {string} [options.relatedName] - The property name that will be used to access the source\n *                                         model instance referencing the target model instance.\n * @param {string} [relatedName] - The property name that will be used to access the source\n *                                 model instance referencing the target model instance\n * @return {OneToOne}\n */\n\n\nfunction oneToOne() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return _construct(OneToOne, args);\n}\n\nexport { fk, attr, many, oneToOne };","map":{"version":3,"names":["_construct","Attribute","ForeignKey","ManyToMany","OneToOne","attr","opts","fk","_len","arguments","length","args","Array","_key","many","_len2","_key2","oneToOne","_len3","_key3"],"sources":["/Users/developer/task/task3/node_modules/redux-orm/es/fields/index.js"],"sourcesContent":["import _construct from \"@babel/runtime/helpers/construct\";\nimport Attribute from \"./Attribute\";\nimport ForeignKey from \"./ForeignKey\";\nimport ManyToMany from \"./ManyToMany\";\nimport OneToOne from \"./OneToOne\";\n/**\n * Contains the logic for how fields on {@link Model}s work\n * and which descriptors must be installed.\n *\n * If your goal is to define fields on a Model class,\n * please use the more convenient methods {@link attr},\n * {@link fk}, {@link many} and {@link oneToOne}.\n *\n * @module fields\n */\n\n/**\n * Defines a value attribute on the model.\n * Though not required, it is recommended to define this for each non-foreign key you wish to use.\n * Getters and setters need to be defined on each Model\n * instantiation for undeclared data fields, which is slower.\n * You can use the optional `getDefault` parameter to fill in unpassed values\n * to {@link Model.create}, such as for generating ID's with UUID:\n *\n * ```javascript\n * import getUUID from 'your-uuid-package-of-choice';\n *\n * fields = {\n *   id: attr({ getDefault: () => getUUID() }),\n *   title: attr(),\n * }\n * ```\n *\n * @param  {Object} [opts]\n * @param {Function} [opts.getDefault] - If you give a function here, its return\n *                                       value from calling with zero arguments will\n *                                       be used as the value when creating a new Model\n *                                       instance with {@link Model#create} if the field\n *                                       value is not passed.\n * @return {Attribute}\n */\n\nfunction attr(opts) {\n  return new Attribute(opts);\n}\n/**\n * Defines a foreign key on a model, which points\n * to a single entity on another model.\n *\n * You can pass arguments as either a single object,\n * or two arguments.\n *\n * If you pass two arguments, the first one is the name\n * of the Model the foreign key is pointing to, and\n * the second one is an optional related name, which will\n * be used to access the Model the foreign key\n * is being defined from, from the target Model.\n *\n * If the related name is not passed, it will be set as\n * `${toModelName}Set`.\n *\n * If you pass an object to `fk`, it has to be in the form\n *\n * ```javascript\n * fields = {\n *   author: fk({ to: 'Author', relatedName: 'books' })\n * }\n * ```\n *\n * Which is equal to\n *\n * ```javascript\n * fields = {\n *   author: fk('Author', 'books'),\n * }\n * ```\n *\n * @param {string|Class<Model>|Object} options - The target Model class, its `modelName`\n *                                               attribute or an options object that\n *                                               contains either as the `to` key.\n * @param {string|Class<Model>} options.to - The target Model class or its `modelName` attribute.\n * @param {string} [options.as] - Name for the new accessor defined for this field. If you don't\n *                                supply this, the key that this field is defined under will be\n *                                overridden.\n * @param {string} [options.relatedName] - The property name that will be used to access\n *                                         a QuerySet for all source models that reference\n *                                         the respective target Model's instance.\n * @param {string} [relatedName] - If you didn't pass an object as the first argument,\n *                                 this is the property name that will be used to\n *                                 access a QuerySet for all source models that reference\n *                                 the respective target Model's instance.\n * @return {ForeignKey}\n */\n\n\nfunction fk() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(ForeignKey, args);\n}\n/**\n * Defines a many-to-many relationship between\n * this (source) and another (target) model.\n *\n * The relationship is modeled with an extra model called the through model.\n * The through model has foreign keys to both the source and target models.\n *\n * You can define your own through model if you want to associate more information\n * to the relationship. A custom through model must have at least two foreign keys,\n * one pointing to the source Model, and one pointing to the target Model.\n *\n * Like `fk`, this function accepts one or two string arguments specifying the other\n * Model and the related name, or a single object argument that allows you to pass\n * a custom through model.\n *\n * If you have more than one foreign key pointing to a source or target Model in the\n * through Model, you must pass the option `throughFields`, which is an array of two\n * strings, where the strings are the field names that identify the foreign keys to\n * be used for the many-to-many relationship. Redux-ORM will figure out which field name\n * points to which model by checking the \"through model\" definition.\n *\n * ```javascript\n * class Authorship extends Model {}\n * Authorship.modelName = 'Authorship';\n * Authorship.fields = {\n *   author: fk('Author', 'authorships'),\n *   book: fk('Book', 'authorships'),\n * };\n *\n * class Author extends Model {}\n * Author.modelName = 'Author';\n * Author.fields = {\n *   books: many({\n *     to: 'Book',\n *     relatedName: 'authors',\n *     through: 'Authorship',\n *\n *     // here this is optional: Redux-ORM can figure\n *     // out the through fields itself since the two\n *     // foreign key fields point to different Models\n *     throughFields: ['author', 'book'],\n *   })\n * };\n *\n * class Book extends Model {}\n * Book.modelName = 'Book';\n * ```\n *\n * You should only define the many-to-many relationship on one side. In the\n * above case of Authors to Books through Authorships, the relationship is\n * defined only on the Author model.\n *\n * @param {string|Class<Model>|Object} options - The target Model class, its `modelName`\n *                                               attribute or an options object that\n *                                               contains either as the `to` key.\n * @param {string|Class<Model>} options.to - The target Model class or its `modelName` attribute.\n * @param {string} [options.as] - Name for the new accessor defined for this field. If you don't\n *                                supply this, the key that this field is defined under will be\n *                                overridden.\n * @param {string|Class<Model>} [options.through] - The through Model class or its `modelName`\n *                                                  attribute. It must declare at least one\n *                                                  foreign key to both source and target models.\n *                                                  If not supplied, Redux-ORM will generate one.\n * @param {string[]} [options.throughFields] - Must be supplied only when a custom through\n *                                             Model has more than one foreign key pointing to\n *                                             either the source or target mode. In this case\n *                                             Redux-ORM can't figure out the correct fields for\n *                                             you, you must provide them. The supplied array should\n *                                             have two elements that are the field names for the\n *                                             through fields you want to declare the many-to-many\n *                                             relationship with. The order doesn't matter;\n *                                             Redux-ORM will figure out which field points to\n *                                             the source Model and which to the target Model.\n * @param {string} [options.relatedName] - The attribute used to access a QuerySet for all\n *                                         source models that reference the respective target\n *                                         Model's instance.\n * @param {string} [relatedName] - If you didn't pass an object as the first argument,\n *                                 this is the property name that will be used to\n *                                 access a QuerySet for all source models that reference\n *                                 the respective target Model's instance.\n * @return {ManyToMany}\n */\n\n\nfunction many() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return _construct(ManyToMany, args);\n}\n/**\n * Defines a one-to-one relationship. In database terms, this is a foreign key with the\n * added restriction that only one entity can point to single target entity.\n *\n * The arguments are the same as with `fk`. If `relatedName` is not supplied,\n * the source model name in lowercase will be used. Note that with the one-to-one\n * relationship, the `relatedName` should be in singular, not plural.\n *\n *\n * @param {string|Class<Model>|Object} options - The target Model class, its `modelName`\n *                                               attribute or an options object that\n *                                               contains either as the `to` key.\n * @param {string|Class<Model>} options.to - The target Model class or its `modelName` attribute.\n * @param {string} [options.as] - Name for the new accessor defined for this field. If you don't\n *                                supply this, the key that this field is defined under will be\n *                                overridden.\n * @param {string} [options.relatedName] - The property name that will be used to access the source\n *                                         model instance referencing the target model instance.\n * @param {string} [relatedName] - The property name that will be used to access the source\n *                                 model instance referencing the target model instance\n * @return {OneToOne}\n */\n\n\nfunction oneToOne() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return _construct(OneToOne, args);\n}\n\nexport { fk, attr, many, oneToOne };"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,kCAAvB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,IAAT,CAAcC,IAAd,EAAoB;EAClB,OAAO,IAAIL,SAAJ,CAAcK,IAAd,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,EAAT,GAAc;EACZ,KAAK,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAArB,EAA6BC,IAAI,GAAG,IAAIC,KAAJ,CAAUJ,IAAV,CAApC,EAAqDK,IAAI,GAAG,CAAjE,EAAoEA,IAAI,GAAGL,IAA3E,EAAiFK,IAAI,EAArF,EAAyF;IACvFF,IAAI,CAACE,IAAD,CAAJ,GAAaJ,SAAS,CAACI,IAAD,CAAtB;EACD;;EAED,OAAOb,UAAU,CAACE,UAAD,EAAaS,IAAb,CAAjB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASG,IAAT,GAAgB;EACd,KAAK,IAAIC,KAAK,GAAGN,SAAS,CAACC,MAAtB,EAA8BC,IAAI,GAAG,IAAIC,KAAJ,CAAUG,KAAV,CAArC,EAAuDC,KAAK,GAAG,CAApE,EAAuEA,KAAK,GAAGD,KAA/E,EAAsFC,KAAK,EAA3F,EAA+F;IAC7FL,IAAI,CAACK,KAAD,CAAJ,GAAcP,SAAS,CAACO,KAAD,CAAvB;EACD;;EAED,OAAOhB,UAAU,CAACG,UAAD,EAAaQ,IAAb,CAAjB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASM,QAAT,GAAoB;EAClB,KAAK,IAAIC,KAAK,GAAGT,SAAS,CAACC,MAAtB,EAA8BC,IAAI,GAAG,IAAIC,KAAJ,CAAUM,KAAV,CAArC,EAAuDC,KAAK,GAAG,CAApE,EAAuEA,KAAK,GAAGD,KAA/E,EAAsFC,KAAK,EAA3F,EAA+F;IAC7FR,IAAI,CAACQ,KAAD,CAAJ,GAAcV,SAAS,CAACU,KAAD,CAAvB;EACD;;EAED,OAAOnB,UAAU,CAACI,QAAD,EAAWO,IAAX,CAAjB;AACD;;AAED,SAASJ,EAAT,EAAaF,IAAb,EAAmBS,IAAnB,EAAyBG,QAAzB"},"metadata":{},"sourceType":"module"}