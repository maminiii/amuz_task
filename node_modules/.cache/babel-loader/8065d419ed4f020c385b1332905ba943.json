{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport { STATE_FLAG } from \"./constants\";\n\nvar defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\n\nexport var eqCheck = defaultEqualityCheck;\n\nvar isOrmState = function isOrmState(arg) {\n  return arg && _typeof(arg) === \"object\" && arg.hasOwnProperty(STATE_FLAG);\n};\n\nvar argsAreEqual = function argsAreEqual(lastArgs, nextArgs, equalityCheck) {\n  return nextArgs.every(function (arg, index) {\n    return isOrmState(arg) && isOrmState(lastArgs[index]) || equalityCheck(arg, lastArgs[index]);\n  });\n};\n\nvar rowsAreEqual = function rowsAreEqual(ids, rowsA, rowsB) {\n  return ids.every(function (id) {\n    return rowsA[id] === rowsB[id];\n  });\n};\n\nvar accessedModelInstancesAreEqual = function accessedModelInstancesAreEqual(previous, ormState, orm) {\n  var accessedInstances = previous.accessedInstances;\n  return Object.entries(accessedInstances).every(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        modelName = _ref2[0],\n        instances = _ref2[1]; // if the entire table has not been changed, we have nothing to do\n\n\n    if (previous.ormState[modelName] === ormState[modelName]) {\n      return true;\n    }\n\n    var _orm$getDatabase$desc = orm.getDatabase().describe(modelName),\n        mapName = _orm$getDatabase$desc.mapName;\n\n    var previousRows = previous.ormState[modelName][mapName];\n    var rows = ormState[modelName][mapName];\n    var accessedIds = Object.keys(instances);\n    return rowsAreEqual(accessedIds, previousRows, rows);\n  });\n};\n\nvar accessedIndexesAreEqual = function accessedIndexesAreEqual(previous, ormState) {\n  var accessedIndexes = previous.accessedIndexes;\n  return Object.entries(accessedIndexes).every(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        modelName = _ref4[0],\n        indexes = _ref4[1];\n\n    return Object.entries(indexes).every(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          column = _ref6[0],\n          values = _ref6[1];\n\n      return values.every(function (value) {\n        return previous.ormState[modelName].indexes[column][value] === ormState[modelName].indexes[column][value];\n      });\n    });\n  });\n};\n\nvar fullTableScannedModelsAreEqual = function fullTableScannedModelsAreEqual(previous, ormState) {\n  return previous.fullTableScannedModels.every(function (modelName) {\n    return previous.ormState[modelName] === ormState[modelName];\n  });\n};\n/**\n * A memoizer to use with redux-orm\n * selectors. When the memoized function is first run,\n * the memoizer will remember the models that are accessed\n * during that function run.\n *\n * On subsequent runs, the memoizer will check if those\n * models' states have changed compared to the previous run.\n *\n * Memoization algorithm operates like this:\n *\n * 1. Has the selector been run before? If not, go to 6.\n *\n * 2. If the selector has other input selectors in addition to the\n *    ORM state selector, check their results for equality with the previous results.\n *    If they aren't equal, go to 6.\n *\n * 3. Some filter queries may have required scanning entire tables during the last run.\n *    If any of those tables have changed, go to 6.\n *\n * 4. Check which foreign key indexes the database has used to speed up queries\n *    during the last run. If any have changed, go to 6.\n *\n * 5. Check which Model's instances the selector has accessed during the last run.\n *    Check for equality with each of those states versus their states in the\n *    previous ORM state. If all of them are equal, return the previous result.\n *\n * 6. Run the selector. Check the Session object used by the selector for\n *    which Model's states were accessed, and merge them with the previously\n *    saved information about accessed models (if-else branching can change\n *    which models are accessed on different inputs). Save the ORM state and\n *    other arguments the selector was called with, overriding previously\n *    saved values. Save the selector result. Return the selector result.\n *\n * @private\n * @param  {Function} func - function to memoize\n * @param  {Function} argEqualityCheck - equality check function to use with normal\n *                                       selector args\n * @param  {ORM} orm - a redux-orm ORM instance\n * @return {Function} `func` memoized.\n */\n\n\nexport function memoize(func) {\n  var argEqualityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\n  var orm = arguments.length > 2 ? arguments[2] : undefined;\n  var previous = {\n    /* Result of the previous function call */\n    result: null,\n\n    /* Arguments to the previous function call (excluding ORM state) */\n    args: null,\n\n    /**\n     * Snapshot of the previous database.\n     *\n     * Lets us know how the tables looked like\n     * during the previous function call.\n     */\n    ormState: null,\n\n    /**\n     * Names of models whose tables have been scanned completely\n     * during previous function call (contains only model names)\n     * Format example: ['Book']\n     */\n    fullTableScannedModels: [],\n\n    /**\n     * Map of which model instances have been accessed\n     * during previous function call.\n     * Contains only PKs of accessed instances.\n     * Format example: { Book: { 1: true, 3: true } }\n     */\n    accessedInstances: {},\n\n    /**\n     * Map of which attribute indexes have been accessed\n     * during previous function call.\n     * Contains only attributes that were actually filtered on.\n     * Author.withId(3).books would add 3 to the authorId index below.\n     * Format example: { Book: { authorId: [1, 2], publisherId: [5] } }\n     */\n    accessedIndexes: {}\n  };\n  return function () {\n    for (var _len = arguments.length, stateAndArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      stateAndArgs[_key] = arguments[_key];\n    }\n    /**\n     * The first argument to this function needs to be\n     * the ORM's reducer state in the user's Redux store.\n     */\n\n\n    var ormState = stateAndArgs[0],\n        args = stateAndArgs.slice(1);\n    var selectorWasCalledBefore = Boolean(previous.args);\n\n    if (selectorWasCalledBefore && argsAreEqual(previous.args, args, argEqualityCheck) && fullTableScannedModelsAreEqual(previous, ormState) && accessedIndexesAreEqual(previous, ormState) && accessedModelInstancesAreEqual(previous, ormState, orm)) {\n      /**\n       * None of this selector's dependencies have changed\n       * since the last time that we called it.\n       */\n      return previous.result;\n    }\n    /**\n     * Start a session so that the selector can access the database.\n     * Make this session immutable. This way we can find out if\n     * the operations that the selector performs are cacheable.\n     */\n\n\n    var session = orm.session(ormState);\n    /* Replace all ORM state arguments by the session above */\n\n    var argsWithSession = args.map(function (arg) {\n      return isOrmState(arg) ? session : arg;\n    });\n    /* This is where we call the actual function */\n\n    var result = func.apply(null, argsWithSession); // eslint-disable-line prefer-spread\n\n    /**\n     * The metadata for the previous call are no longer valid.\n     * Update cached values.\n     */\n\n    previous = {\n      /* Arguments that were passed to the selector */\n      args: args,\n\n      /* Selector result */\n      result: result,\n\n      /* Redux state slice for session.state */\n      ormState: ormState,\n\n      /* Rows retrieved by resolved primary key */\n      accessedInstances: session.accessedModelInstances,\n\n      /* Foreign key indexes that were used to speed up queries */\n      accessedIndexes: session.accessedIndexes,\n\n      /* Tables that had to be scanned completely */\n      fullTableScannedModels: session.fullTableScannedModels\n    };\n    return result;\n  };\n}","map":{"version":3,"names":["_slicedToArray","_typeof","STATE_FLAG","defaultEqualityCheck","a","b","eqCheck","isOrmState","arg","hasOwnProperty","argsAreEqual","lastArgs","nextArgs","equalityCheck","every","index","rowsAreEqual","ids","rowsA","rowsB","id","accessedModelInstancesAreEqual","previous","ormState","orm","accessedInstances","Object","entries","_ref","_ref2","modelName","instances","_orm$getDatabase$desc","getDatabase","describe","mapName","previousRows","rows","accessedIds","keys","accessedIndexesAreEqual","accessedIndexes","_ref3","_ref4","indexes","_ref5","_ref6","column","values","value","fullTableScannedModelsAreEqual","fullTableScannedModels","memoize","func","argEqualityCheck","arguments","length","undefined","result","args","_len","stateAndArgs","Array","_key","slice","selectorWasCalledBefore","Boolean","session","argsWithSession","map","apply","accessedModelInstances"],"sources":["/Users/developer/task/task3/node_modules/redux-orm/es/memoize.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport { STATE_FLAG } from \"./constants\";\n\nvar defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\n\nexport var eqCheck = defaultEqualityCheck;\n\nvar isOrmState = function isOrmState(arg) {\n  return arg && _typeof(arg) === \"object\" && arg.hasOwnProperty(STATE_FLAG);\n};\n\nvar argsAreEqual = function argsAreEqual(lastArgs, nextArgs, equalityCheck) {\n  return nextArgs.every(function (arg, index) {\n    return isOrmState(arg) && isOrmState(lastArgs[index]) || equalityCheck(arg, lastArgs[index]);\n  });\n};\n\nvar rowsAreEqual = function rowsAreEqual(ids, rowsA, rowsB) {\n  return ids.every(function (id) {\n    return rowsA[id] === rowsB[id];\n  });\n};\n\nvar accessedModelInstancesAreEqual = function accessedModelInstancesAreEqual(previous, ormState, orm) {\n  var accessedInstances = previous.accessedInstances;\n  return Object.entries(accessedInstances).every(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        modelName = _ref2[0],\n        instances = _ref2[1];\n\n    // if the entire table has not been changed, we have nothing to do\n    if (previous.ormState[modelName] === ormState[modelName]) {\n      return true;\n    }\n\n    var _orm$getDatabase$desc = orm.getDatabase().describe(modelName),\n        mapName = _orm$getDatabase$desc.mapName;\n\n    var previousRows = previous.ormState[modelName][mapName];\n    var rows = ormState[modelName][mapName];\n    var accessedIds = Object.keys(instances);\n    return rowsAreEqual(accessedIds, previousRows, rows);\n  });\n};\n\nvar accessedIndexesAreEqual = function accessedIndexesAreEqual(previous, ormState) {\n  var accessedIndexes = previous.accessedIndexes;\n  return Object.entries(accessedIndexes).every(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        modelName = _ref4[0],\n        indexes = _ref4[1];\n\n    return Object.entries(indexes).every(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          column = _ref6[0],\n          values = _ref6[1];\n\n      return values.every(function (value) {\n        return previous.ormState[modelName].indexes[column][value] === ormState[modelName].indexes[column][value];\n      });\n    });\n  });\n};\n\nvar fullTableScannedModelsAreEqual = function fullTableScannedModelsAreEqual(previous, ormState) {\n  return previous.fullTableScannedModels.every(function (modelName) {\n    return previous.ormState[modelName] === ormState[modelName];\n  });\n};\n/**\n * A memoizer to use with redux-orm\n * selectors. When the memoized function is first run,\n * the memoizer will remember the models that are accessed\n * during that function run.\n *\n * On subsequent runs, the memoizer will check if those\n * models' states have changed compared to the previous run.\n *\n * Memoization algorithm operates like this:\n *\n * 1. Has the selector been run before? If not, go to 6.\n *\n * 2. If the selector has other input selectors in addition to the\n *    ORM state selector, check their results for equality with the previous results.\n *    If they aren't equal, go to 6.\n *\n * 3. Some filter queries may have required scanning entire tables during the last run.\n *    If any of those tables have changed, go to 6.\n *\n * 4. Check which foreign key indexes the database has used to speed up queries\n *    during the last run. If any have changed, go to 6.\n *\n * 5. Check which Model's instances the selector has accessed during the last run.\n *    Check for equality with each of those states versus their states in the\n *    previous ORM state. If all of them are equal, return the previous result.\n *\n * 6. Run the selector. Check the Session object used by the selector for\n *    which Model's states were accessed, and merge them with the previously\n *    saved information about accessed models (if-else branching can change\n *    which models are accessed on different inputs). Save the ORM state and\n *    other arguments the selector was called with, overriding previously\n *    saved values. Save the selector result. Return the selector result.\n *\n * @private\n * @param  {Function} func - function to memoize\n * @param  {Function} argEqualityCheck - equality check function to use with normal\n *                                       selector args\n * @param  {ORM} orm - a redux-orm ORM instance\n * @return {Function} `func` memoized.\n */\n\n\nexport function memoize(func) {\n  var argEqualityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\n  var orm = arguments.length > 2 ? arguments[2] : undefined;\n  var previous = {\n    /* Result of the previous function call */\n    result: null,\n\n    /* Arguments to the previous function call (excluding ORM state) */\n    args: null,\n\n    /**\n     * Snapshot of the previous database.\n     *\n     * Lets us know how the tables looked like\n     * during the previous function call.\n     */\n    ormState: null,\n\n    /**\n     * Names of models whose tables have been scanned completely\n     * during previous function call (contains only model names)\n     * Format example: ['Book']\n     */\n    fullTableScannedModels: [],\n\n    /**\n     * Map of which model instances have been accessed\n     * during previous function call.\n     * Contains only PKs of accessed instances.\n     * Format example: { Book: { 1: true, 3: true } }\n     */\n    accessedInstances: {},\n\n    /**\n     * Map of which attribute indexes have been accessed\n     * during previous function call.\n     * Contains only attributes that were actually filtered on.\n     * Author.withId(3).books would add 3 to the authorId index below.\n     * Format example: { Book: { authorId: [1, 2], publisherId: [5] } }\n     */\n    accessedIndexes: {}\n  };\n  return function () {\n    for (var _len = arguments.length, stateAndArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      stateAndArgs[_key] = arguments[_key];\n    }\n\n    /**\n     * The first argument to this function needs to be\n     * the ORM's reducer state in the user's Redux store.\n     */\n    var ormState = stateAndArgs[0],\n        args = stateAndArgs.slice(1);\n    var selectorWasCalledBefore = Boolean(previous.args);\n\n    if (selectorWasCalledBefore && argsAreEqual(previous.args, args, argEqualityCheck) && fullTableScannedModelsAreEqual(previous, ormState) && accessedIndexesAreEqual(previous, ormState) && accessedModelInstancesAreEqual(previous, ormState, orm)) {\n      /**\n       * None of this selector's dependencies have changed\n       * since the last time that we called it.\n       */\n      return previous.result;\n    }\n    /**\n     * Start a session so that the selector can access the database.\n     * Make this session immutable. This way we can find out if\n     * the operations that the selector performs are cacheable.\n     */\n\n\n    var session = orm.session(ormState);\n    /* Replace all ORM state arguments by the session above */\n\n    var argsWithSession = args.map(function (arg) {\n      return isOrmState(arg) ? session : arg;\n    });\n    /* This is where we call the actual function */\n\n    var result = func.apply(null, argsWithSession); // eslint-disable-line prefer-spread\n\n    /**\n     * The metadata for the previous call are no longer valid.\n     * Update cached values.\n     */\n\n    previous = {\n      /* Arguments that were passed to the selector */\n      args: args,\n\n      /* Selector result */\n      result: result,\n\n      /* Redux state slice for session.state */\n      ormState: ormState,\n\n      /* Rows retrieved by resolved primary key */\n      accessedInstances: session.accessedModelInstances,\n\n      /* Foreign key indexes that were used to speed up queries */\n      accessedIndexes: session.accessedIndexes,\n\n      /* Tables that had to be scanned completely */\n      fullTableScannedModels: session.fullTableScannedModels\n    };\n    return result;\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}